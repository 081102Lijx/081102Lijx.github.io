[{"title":"Grokking Algorithms","url":"/2024/09/26/Grokking-Algorithms/","content":"快速排序\r\n基本思想：将数组分解直至满足基线条件，使用递归调用排序\r\n\r\n\r\n快速排序\r\n\r\ndef quicksort(array):\tif len(array) &lt; 2:\t\treturn array\telse:\t\tpivot = array[0]\t\tless = [i for i in array[1:] if i &lt;= pivot] #由所有小于基准值的元素组成\t\tgreater = [i for i in array[1:] if i &gt; pivot]\t\treturn quicksort(less) + [pivot] + quicksort(greater)\r\n\r\n散列表（哈希表）\r\n散列函数可以“将输入映射到数字”。\r\n应用案例\r\n\r\n用于“大海捞针”式的寻找。例如在访问网站时，计算机需要将网页地址转换为IP地址，即将网址映射到IP地址。该过程被称为DNS解析，可以应用哈希表实现。\r\n防止重复。利用哈希表映射寻找表内内容是否出现了重复。\r\n\r\n\r\n\r\n哈希表(避免重复）\r\n\r\nvoted = &#123;&#125;def check_voter(name):    if voted.get(name):        print(&quot;kick them out!&quot;)    else:        voted[name] = True        print(&quot;let them vote!&quot;)check_voter(&quot;tom&quot;)check_voter(&quot;mike&quot;)check_voter(&quot;tom&quot;)\r\n\r\n\r\n将散列表用于缓存。例如cache存储，内存，外存和页表。\r\n\r\n\r\n\r\n哈希表（缓存）\r\n\r\ncache = &#123;&#125;def get_page(url):    if cache.get(url):        return cache[url]    else:        data = get_data_from_server(url)        cache[url] = data        return data\r\n\r\n冲突的解决和哈希表的性能\r\n哈希表的平均性能为O(1)，单数冲突的产生会导致哈希表的性能在最糟糕的情况下都为O(n)，即比很多线性表都要慢，因此需要避免冲突。一般解决办法式有较低的填装因子和良好的散列函数。\r\n填装因子\r\n当填装因子大于0.7，就需要调整列表的长度。\r\n良好的散列函数\r\n良好的散列函数让数组中的值呈均匀分布。\r\n广度优先搜索\r\n图\r\n图可以用于模拟不同的东西是如何相连的。\r\n算法实现\r\n首先创建一个队列，用于搜索每一个节点的相连节点。即由队列组成一个拓扑图，由此出发进行搜索。\r\n\r\n\r\n图\r\n\r\ngraph = &#123;&#125;graph[&quot;you&quot;] = [&quot;alice&quot;, &quot;bob&quot;, &quot;claire&quot;]graph[&quot;bob&quot;] = [&quot;anuj&quot;, &quot;peggy&quot;]graph[&quot;alice&quot;] = [&quot;peggy&quot;]graph[&quot;claire&quot;] = [&quot;thom&quot;, &quot;jonny&quot;]graph[&quot;anuj&quot;] = &#123;&#125;graph[&quot;peggy&quot;] = &#123;&#125;graph[&quot;thom&quot;] = &#123;&#125;graph[&quot;jonny&quot;] = &#123;&#125;#生成一个图from collections import deque#建立队列用于搜索def search(name):    search_queue = deque()    search_queue += graph[name]#放入搜索队列    searched = []#已搜索过的元素，避免循环搜索    while search_queue:#如果搜索队列不为空        person = search_queue.popleft()#从队列中弹出搜索项        if person not in searched:            if person_is_seller(person):                print(person + &quot;is a mango seller!&quot;)                return True            else:                search_queue += graph[person]                searched.append(person)    return False    def person_is_seller(name):    return name[-1] == &#x27;m&#x27;search(&quot;you&quot;)\r\n\r\n狄克斯特拉算法\r\n狄克斯特拉算法用于寻找加权图中的最短路径，但只适用于有向无环图和正权重。\r\n算法核心思想在于寻找最便宜的节点，检查他们的邻居，检查是否有前往他们的更短路径，如果有就更新其开销，重复这个过程直到遍历所有节点，最后计算最终路径。\r\n在计算过程中需要不断根据最短路径更新权重哈希表和父节点哈希表中的信息。\r\n\r\n\r\n狄克斯特拉算法实现\r\n\r\n#狄克斯特拉算法graph = &#123;&#125;graph[&quot;satrt&quot;] = &#123;&#125;graph[&quot;satrt&quot;][&quot;a&quot;] = 6graph[&quot;satrt&quot;][&quot;b&quot;] = 2#建立起点的两个邻居及其权重graph[&quot;a&quot;] = &#123;&#125;graph[&quot;a&quot;][&quot;fin&quot;] = 1graph[&quot;b&quot;] = &#123;&#125;graph[&quot;b&quot;][&quot;a&quot;] = 3graph[&quot;b&quot;][&quot;fin&quot;] = 5graph[&quot;fin&quot;] = &#123;&#125;#完成图中其他节点的建立#创建哈希表存储初始计算结点的开销infinity = float(&quot;inf&quot;)costs = &#123;&#125;costs[&quot;a&quot;] = 6costs[&quot;b&quot;] = 2costs[&quot;fin&quot;] = infinity#创建哈希表存储初始计算的父节点parents = &#123;&#125;parents[&quot;a&quot;] = &quot;start&quot;parents[&quot;b&quot;] = &quot;start&quot;parents[&quot;fin&quot;] = None#建立数组用于存放已经搜索过的节点processed = []#算法def find_lowest_cost_node(costs):#寻找最便宜的点    lowest_cost = float(&quot;inf&quot;)    lowest_cost_node = None    for node in costs:        cost  = costs[node]        if cost &lt; lowest_cost and node not in processed:            lowest_cost = cost            lowest_cost_node = node    return lowest_cost_nodenode = find_lowest_cost_node(costs)while node is not None:#遍历所有节点    cost = costs[node]    neighbors = graph[node]#得到当前节点邻居的哈希表    for n in neighbors.keys():        new_cost = cost + neighbors[n]        if costs[n] &gt; new_cost:#如果当前节点前往该邻居更近            costs[n] = new_cost#就更新节点的开销            parents[n] = node#并将邻居的父节点设为当前的节点    processed.append(node)    node = find_lowest_cost_node(costs)\r\n\r\n贪婪算法\r\n每步都采取最优的做法，即每步都选择局部最优解，最终得到的就是全局最优解。\r\n集合覆盖问题\r\n假设有一个广播节目，要让全美50个州的听众都听得到，但因为每一个广播台播出都需要费用，故要选择在尽可能少的广播台播出。\r\n\r\n\r\n贪婪算法（集合覆盖问题）\r\n\r\nstates_needed = set([&quot;mt&quot;, &quot;wa&quot;, &quot;or&quot;, &quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;, &quot;ca&quot;,&quot;az&quot;])stations = &#123;&#125;stations[&quot;kone&quot;] = set([&quot;id&quot;, &quot;nv&quot;, &quot;ut&quot;])stations[&quot;ktwo&quot;] = set([&quot;wa&quot;, &quot;id&quot;, &quot;mt&quot;])stations[&quot;kthree&quot;] = set([&quot;or&quot;, &quot;nv&quot;, &quot;ca&quot;])stations[&quot;kfour&quot;] = set([&quot;nv&quot; , &quot;ut&quot;])stations[&quot;kfive&quot;] = set([&quot;ca&quot;, &quot;az&quot;])final_stations = set()while states_needed:    best_station = None    states_covered = set()    for station, states_for_station in stations.items():        covered = states_needed &amp; states_for_station#求需要和已覆盖的交集        if len(covered) &gt; len(states_covered):            best_station = station            states_covered = covered    final_stations.add(best_station)    states_needed -= states_coveredprint(final_stations)\r\n\r\nNP完全问题\r\n“以难解著称的问题”\r\n\r\n元素较少时运行速度很快，但随着元素的增加运行速度变得非常慢\r\n涉及所有组合的问题\r\n不能将问题分为小问题，必须考虑各种可能的情况\r\n如果问题涉及序列且难以解决\r\n如果问题涉及集合\r\n如果问题可以转化为集合覆盖或者旅行商问题\r\n\r\n则可能是NP完全问题。\r\n动态规划\r\n如何设计出动态规划解决方案？\r\n\r\n每种动态规划解决方案都涉及网格\r\n单元格中的值通常就是你要优化的值\r\n每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题。\r\n\r\n_没有放诸四海而皆准的动态规划算法。\r\nK最近邻算法（KNN）\r\n可以用作制作推荐系统。如果需要量度两个用户的相似度，还可以使用余弦相似度。\r\n使用KNN时挑选合适的特征至关重要。\r\n\r\n和内容紧密相关的特征\r\n不偏不倚的特征\r\n\r\nKNN可以用于机器学习来创建推荐系统或识别系统。通过大量的数字图像提取特征来建立KNN算法的参考库，例如谷歌使用的OCR（光学字符识别），垃圾邮件过滤器（使用朴素贝叶斯分类器）等。\r\n将深入的方向\r\n\r\nB树，红黑树，堆，伸展树\r\n反向索引\r\n傅里叶变换\r\nDiffie-Hellman算法\r\n所有的图算法都可以用线性规划实现。\r\nSimplex算法。\r\n\r\n","tags":["算法学习"]},{"title":"Linux学习","url":"/2024/04/14/Linux%E5%AD%A6%E4%B9%A0/","content":"前言：怎么就想着要学Linux？\r\n"},{"title":"Neo4j知识图谱进展","url":"/2024/04/12/Neo4j%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%BF%9B%E5%B1%95/","content":"1、目标任务\r\n完成有100个节点的知识图谱绘制\r\n2、选题\r\n考研数学知识点\r\n3、进度\r\n61个节点\r\n4、tips\r\n4.1、可以使用python进行批量节点关系绘制（还未细究）（已更新）\r\n可以细究为利用导入数据，编程等方法批量导入生成数据，减少建立节点的工作量和错误率。\r\n在仔细阅读教程后发现，使用python只是因为使用者对python足够熟悉，并且python有插件可以支持neo4j的知识图谱的搭建，批量导入并不是一定需要python。\r\n4.2、在绘制节点时要注意不要出现同名节点\r\n目前发现在第三章和第四章有同名的节点，导致直接生成了一个横跨两个章节的关系，并且由于Neo4j的自增设置，无法在原节点上更改关系，于是出现了节点和关系的冗余。\r\n收尾时要记得删除多余关系。\r\n4.3、手动输入的缺点\r\n适合数量较少的情况，数量超过30个很容易搞混。\r\n5、目标进度\r\n周内基本完成绘制。\r\n\r\n更新于2024/4/13 # --完成知识图谱绘制 ## --问题\r\n在绘制时出现了同名节点，关系变得很乱，手动删除又十分麻烦（生气\r\n\r\n更新于2024/4/14\r\nneo4j本身的发掘\r\n在查找neo4j操作时，找到了官网上的操作指南。事实上，在绘制过程中用到的过程不及其功能的百分之一。固然人工或半人工的构建模式是它最大的短板，它本身的功能和用途也不应该因为这个缺点而被忽视。\r\n知识图谱的发掘\r\n在查找最新的知识图谱的相关文献时，发现知识图谱因为它的直观的特点，在近一个月就有不同领域的对知识图谱的应用技术的开发，包括但不限于趋势预测，风险分析，安全决策，资源配置等，甚至看到了水电站发电量的优化处理。可见目前所看到的优化理论知识只是优化算法的冰山一角，lp的观点没有问题，但水文这座陈旧的大厦依然需要CS来注入足够新鲜的血液。\r\n\r\nOVER\r\n"},{"title":"word排版学习","url":"/2024/07/04/word%E6%8E%92%E7%89%88%E5%AD%A6%E4%B9%A0/","content":"如何给每个公式后面添加编号？\r\n首先在公式框内输入#()，将光标移入括号内，随后点入插入-文本部件-域，\r\n\r\n\r\n域\r\n\r\n进入设置域的属性，\r\n\r\n\r\n域属性\r\n\r\n确定后可以看见括号内已经出现了数字，这时候把光标移出括号，按下回车，就实现了公式编号。在后续的公式中重复上述步骤即可自动编号。\r\n❗注意： 1. 括号一定要使用英文版 2.\r\n在写入编号的时候检查一下公式的括号是否完整，公式本身是否正确，如果不正确是不能编号的\r\n3. 光标一定要移到编号括号以外，公式格式以内再回车\r\nword转pdf图片错位、长宽大小改变怎么办？\r\n在word内转pdf时选择 打印-打印为Adobe Acrobat pdf-保存至桌面\r\n即可解决。\r\n","tags":["课设"]},{"title":"网站为何？","url":"/2024/03/31/%E5%86%99%E4%B8%80%E5%86%99%E6%96%87%E7%AB%A0/","content":"思路来自..\r\n去年年末第一次做了课设。对于一个设计，时间短，任务重；但对于一个作业，一个完整的解决问题的思路而言，时间还是太长。经常写着写着就忘了在这之前想到的好点子。这时我想起了补工程地质的时候查到的美国地质学家自己的石头网站，有关科普的，有关旅程的，有关成长的，一切都可以展现在小小的网页上。这是建网站的第一个契机。\r\n最近又要开始做课设，更兼需要了解如何写论文，如何使用Linux，这是三项十分重大的任务，是没有笔记万万完成不了的。我曾经尝试使用OneNote做跟踪式的思路记录，但是发现输入公式和表格是在太费时间，而且移植性很差，copy到word里简直就是灾难。那天突然想起来markdown，想起来可以自己建一个网站。某些契机下决定使用hexo建立自己的第一个网站，这算是网站的第一篇文章，就算一个开篇题词了。\r\n# 想在网站上写点什么？\r\n很重要的部分是课设的编程进度和编程思路，同时需要记录latex语言的学习进展。其他的诸如对计算机科学领域兴趣点的发掘，专业结合的idea，日后论文的选题及进度都需要挂在网站上作为一个记录。\r\n当然，还有一个很重要的作用，就是练习使用markdown，争取能更方便更美观的和整个网络领域交流。\r\n也就是个大型笔记本，努努力，还能交互的那种\r\n祝课设、论文及CS学习一切顺利。\r\n"},{"title":"数据结构与算法分析学习笔记","url":"/2024/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"第一章 程序设计：综述\r\n1.3 递归简论\r\n编写递归程序时，要牢记递归的四条基本法则：\r\n\r\n基准情形\r\n要有进展\r\n设计法则\r\n合成效益法则\r\n\r\n1.5 C++细节\r\n1.5.1 指针\r\n指针变量是一种存放另一对象所占用的地址的变量。例如如下例程：\r\nint main() &#123;\tIntCell* m;\tm = new IntCell(5);\tm-&gt;write(5);\tcout &lt;&lt; &quot;Cell contents: &quot; &lt;&lt; m-&gt;read() &lt;&lt; endl;\t\tdelete m;\treturn 0;&#125;\r\n\r\n声明\r\n\r\n其中，星号*表明m是一个指针变量，允许他指向一个IntCell对象。m的值是他所指向的对象的地址。\r\n\r\n对象的动态创建\r\n\r\n操作符new返回一个指向新创建对象的指针。\r\n\r\n垃圾收集与delete\r\n\r\n当一个通过new操作符被分配地址的对象不再被引用时，必须（通过一个指针）对该对象应用delete操作，否则该对象使用的内存就会丢失。一个重要的规则是，在能够使用自动变量的时候不要使用new操作符。\r\n\r\n指针的赋值和比较\r\n\r\n在C++中，指针变量的赋值和比较是基于指针的值，也即基于指针所存储的内存地址进行的。于是，如果他们指向相同的对象，两个指针变量相等，如果他们指向不同的对象，即使他们指向的两个对象本身是相等的，其值也是不相等的。\r\n\r\n通过指针访问对象的成员\r\n\r\n如果一个指针变量指向一个类类型的对象，那么所指对象的（可见）成员能够通过-&gt;操作符被访问。\r\n1.5.2 左值、右值和引用\r\n如果程序中有一个变量名，那么他就是一个左值。\r\n在C++11中，左值引用 的声明是通过在某个类型后防止一个符号\r\n&amp; 来进行的。右值引用 是通过在某个类型后面放置一个\r\n&amp;&amp; 来进行的。\r\n左值引用的用途\r\n1、给结构复杂的名称起别名\r\n2、范围for循环\r\n3、避免复制\r\n","tags":["学习记录"]},{"title":"水电站课设(二)","url":"/2024/06/24/%E6%B0%B4%E7%94%B5%E7%AB%99%E8%AF%BE%E8%AE%BE-%E4%BA%8C/","content":"2024.6.23 好久不见。 \r\n第六学期的考试正式结束，意味着小学期的课设正式开始。水电站课程设计的任务在十天前已经下发，现在来做一个总结。\r\n## 使用数据\r\n计算期初水位：173.45 优化调度最小下泄流量：4690 比较年份：1949\r\n新任务\r\n提取各时段的运行规则。根据水库优化调度模型求解结果，提取各时段的调度规则。\r\n问题分析\r\n-- 使用的数据是水库优化调度模型所得到的求解结果 --\r\n目前需要首先重新修正优化调度模型，修正结果，增加数据结果，形成数据总表\r\n代码改进\r\n在阅读文献的时候没有发现有设置汛期水位完全不变的情况，故现在对结课设计进行改变，取消汛期水位限制。另外需要将所有约束条件放入if内，修正递推函数。\r\n目前决定重新编制优化调度代码，首先列出约束条件、初始值、递推函数，预计明天完善完成。代码如下：\r\n\r\n\r\n代码一\r\n\r\n%%水库优化调度代码（第二版）%确定初始值及数据结构V(1) = 377.45;%计算初始库容Z(1) = 175;%计算初始水位Pb = 499;%保证出力%设决策变量为下泄流量Qfd(t,1),可能出现弃水Qqs(t,1)%%约束条件编制%发电水头约束H(t) = head(Qxx,hsy);%输入下泄流量及上游水头%水电站预想出力限制yxcl(t) = Yuxcl(H(t));%输入当前水头%水电站最大过流能力限制xxnl(t) = Xiaxnl(hsy);%输入当前上游水位%生态流量限制Qst = input(&quot;最小生态流量为&quot;);%本次计算为5690%水量平衡约束V(t+1) = V(t)+(Qrk(t)-Qfd(t)-Qqs(t))*T(t);%库容曲线约束Z(t+1) = Kurqx(V(t+1));%当前时段末库容%库水位约束Z(t) &gt;= 145;Z(t) &lt;= 185;%初末库水位约束Z(1) = 175;Z(36) = 175;%指标函数P(t) = k*Qfd(t)*H(t);if P(t) &gt; Pb    P(t) = P(t);else    P(t) = P(t) + b*(P(t)-Pb);%b为惩罚系数end%%递推函数SumP(t) = max(P(t)+SumP(t+1));\r\n\r\n\r\n今日任务\r\n处理状态和决策离散化与时段平均出力的计算方法和具体代码。\r\n进度\r\n基本完成代码编制，但是数据意义还需要思考，另需要正确获取最优解的数值。\r\n新知识点\r\nmax函数意为返回数组的最大值。\r\n明日任务\r\n完成动态规划代码修改\r\n\r\n进度\r\n昨晚进行到需要在已得到数据中提取需要的最优解的一组数据，但收工后思考之后发现，如果按照真正计算出来的所有结果来选择最优解，就失去了所谓动态规划面向时段的优势和意义，即无视了动态规划的性质——最优解的每个局部解也都是最优的。\r\n故现在开始思考，为什么课本上和课堂上老师都在强调逆推过程而不是更加符合时间顺序的顺推过程？目前我认为，逆推时后一时段的水位和面临时段的来流可以看作八个约束条件之一，每一个时段的计算都是已知结果通过下泄流量来确定上一时段的库容和水位，依此找到确定结果的放水过程的最优解。\r\n结论&amp;任务\r\n上述思想可行且所得到的结果效果很好，和结果设计版本相比有较大的完善。在结课作业中尚有一项未能完成，即惩罚因子的大小和保证率的关系。接下来寻找一下二者的函数关系。\r\n结论\r\n没有找到关系☹️\r\n现附所有动态规划代码如下：\r\n\r\n\r\n代码二\r\n\r\n%%水库优化调度代码（第二版）%确定初始值及数据结构n = 36;%计算时段数Vmin = 171.5;Vmax = 505;Z = zeros(36,1000);V = zeros(36,1000);V(36,:) = 377.45;V(1,:) = 377.45;Z(1,:) = 175;Z(36,:) = 175;%计算初始水位Pb = 499;%保证出力P = zeros(36,1000);SumP = 0;T = 10*3600*24/100000000;%各时段时间间隔%设决策变量为下泄流量Qfd(t,1),可能出现弃水Qqs(t,1)%生态流量限制Qst = 5690;%本次计算为5690%%单时段离散化与平均出力的计算方法%将一时段的状态V(t)离散为M个数值%又水库水位限制为(145,185)%故首先选择将水库库容离散为40个数值（即一米一个库容）%又首先需要确定Qfd的离散值%故制作Qfd初始值表格%表格范围设置为（生态流量，时段最大下泄流量）%此次计算设Qfd为决策变量b = linspace(0,1,100);%b = 0.8;for k = 1:1000flag = 0;for j = 1:35t = n-j;%if t == 1    i = 1;    Qxx(t,i) = abs(Qrk(t,1) - (V(t+1,1) - V(t,1))/T);     %库容曲线约束     Z(t,i) = Kurqx(V(t,i));%当前时段末库容     %发电水头约束     [H(t+1,i),kcl(t,i)] = head(Qxx(t,i),Z(t,i));%输入下泄流量及上游水头     %时段平均出力     P(t+1,:) = kcl(t,i)*Qxx(t,i)*H(t,i)/10000;     Pmax(t+1,i) = P(t+1,i);     h(t+1,i) = H(t+1,i);     break;else%&#125;for i = 1:1000%水电站最大过流能力限制    xxnl(t) = Xiaxnl(Z(t+1,i));%输入当前上游水位,计算当前时段水库最大下泄能力    Qfd = linspace(Qst,xxnl(t),1000);%Qfd初始数组，共1000个数据点                V(t,i) = V(t+1,i) - (Qrk(t+1,1)-Qfd(i))*T;                        if V(t,i) &lt; Vmin                V(t,i) = Vmin;                Qxx(t+1,i) = abs(Qrk(t+1,1) - (V(t+1) - V(t))/T);                %库容曲线约束            Z(t,i) = Kurqx(V(t,i));%当前时段末库容            %发电水头约束            [H(t+1,i),kcl(t+1,i)] = head(Qxx(t+1,i),Z(t,i));%输入下泄流量及上游水头            if H(t+1,i) &lt; 0                continue;%继续i循环            end            %时段平均出力            P(t+1,i) = kcl(t+1,i)*Qxx(t+1,i)*H(t+1,i)/10000;            %水电站预想出力限制            yxcl(t+1,i) = Yuxcl(H(t+1,i));%输入当前水头                continue;%跳出i循环                elseif V(t,i) &gt; Vmax                Qqs(t+1,i) = (V(t,i)-Vmax)/T;                V(t,i) = Vmax;                Qxx(t+1,i) = abs(Qrk(t+1,1) - (V(t,i) - V(t+1,i))/T);            else                Qxx(t+1,i) = Qfd(i);            end                       %库容曲线约束            Z(t,i) = Kurqx(V(t,i));%当前时段末库容            %发电水头约束            [H(t+1,i),kcl(t+1,i)] = head(Qxx(t+1,i),Z(t,i));%输入下泄流量及上游水头            %时段平均出力            if H(t+1,i) &lt; 0                continue;            end            P(t+1,i) = kcl(t+1,i)*Qxx(t+1,i)*H(t+1,i)/10000;            %水电站预想出力限制            yxcl(t+1,i) = Yuxcl(H(t+1,i));%输入当前水头            %%指标函数            %            if P(t,i) &gt; yxcl(t)                P(t,i) = yxcl(t);                %flag(t) = 1;            %&#125;            elseif P(t+1,i) &gt; Pb &amp;&amp; P(t,i) &lt; yxcl(t)                P(t+1,i) = P(t+1,i);                %flag(t) = 1;            else                P(t+1,i) = P(t+1,i) + b(1,k)*(P(t+1,i)-Pb);%b为惩罚系数            endend%for f = 1:999    if P(t+1,f) &gt; P(t+1,f+1)        Ppro(t+1,f) = P(t+1,f);       endend[Pmax(t+1,1),l] = max(Ppro(t+1,1:200));V(t,:) = V(t,l);Z(t,:) = Z(t,l);Q(t+1,1) = Qxx(t+1,l);qs(t+1,1) = Qqs(t+1,l);h(t+1,1) = H(t+1,l);endendfor m = 1:36if Pmax(m,1) &gt; Pb    flag = flag+1;endendper(k,1) = flag/36;end\r\n\r\n做出图像如下：\r\n \r\n明日任务\r\n读文献，基本得出函数关系式，基本确定编程思路，得出所有可以用于训练模型的数据。\r\n\r\n读文献有感\r\n\r\n具体阅读了有关NSGA-Ⅱ(Non-dominated Sorting Genetic\r\nAlgorithm)的优化思路和实现方法，如果在课设报告提交前尚有时间，可以考虑把优化调度的方法从动态规划改变为NSGA。\r\n[1] A Fast Non-dominated Sorting Genetic Algorithm For Multi-objective\r\nOptimization:NSGA-Ⅱ\r\n粒子群优化算法（PSO）由鸟群寻找食物得到灵感，通过计算寻找“最好的”粒子，即“离食物最近的”粒子，因此可用于在已有优化调度数据的前提下拟合提取调度函数。\r\n\r\n有一关键评价函数，优化适应度函数。用于评价每一个粒子的“好坏”，从而决定优化方向。\r\n调度函数表达式\r\n\\[ Q_{t} = \\alpha_{t} \\cdot I_{t} +\r\n\\beta_{t} \\cdot _V{t} \\]\r\n其中，\\(Q_{t}\\)\r\n为t时段下泄流量，\\(I_{t}\\)\r\n为t时段入流，\\(V_{t}\\)\r\n为t时段初库容.\r\nmatlab语法学习\r\n1.函数句柄：在matlab中，函数可以像变量一样进行传递和操作。函数句柄就是指向函数的指针，可以调用函数或者将函数作为参数传递给其他函数。\r\n2.@符号：在matlab中，@符号用于创建函数句柄。\r\nPSO算法具体实现代码\r\nhttp://t.csdnimg.cn/Xpizk\r\n\r\n\r\nPSO算法\r\n\r\n%pop——种群数量%dim——问题维度%ub——变量上界，[1,dim]矩阵%lb——变量下界，[1,dim]矩阵%fobj——适应度函数（指针）%MaxIter——最大迭代次数%Best_Pos——x的最佳值%Best_Score——最优适应度 clc;clear all;close all;pop=50;dim=2;ub=[10,10];lb=[-10,-10];vmax=[2,2];vmin=[-2,-2];maxIter=100;fobj=@(X)fun(X);[Best_Pos,Best_fitness,IterCurve]=pso(pop,dim,ub,lb,fobj,vmax,vmin,maxIter);figureplot(IterCurve,&#x27;r&#x27;,&#x27;linewidth&#x27;,2);grid on;disp([&#x27;求解得到的x1，x2是:&#x27;,num2str(Best_Pos(1)),&#x27; &#x27;,num2str(Best_Pos(2))]);disp([&#x27;最优解对应的函数:&#x27;,num2str(Best_fitness)]);%%确定计算初始值 function [X]=initialization(pop,ub,lb,dim)%得到在范围内的初始数据    for i=1:pop        for j=1:dim            X(i,j)=(ub(j)-lb(j))*rand()+lb(j);%在限定的          end     endendfunction fitness=fun(x)    fitness=sum(x.^2);endfunction [X]=BoundaryCheck(X,ub,lb,dim)%检查原始数据    for i=1:dim        if X(i)&gt;ub(i)            X(i)=ub(i);        end        if X(i)&lt;lb(i)            X(i)=lb(i);        end    endend%%PSO计算function [Best_Pos,Best_fitness,IterCurve]=pso(pop,dim,ub,lb,fobj,vmax,vmin,maxIter)c1=2.0;c2=2.0;V=initialization(pop,vmax,vmin,dim);X=initialization(pop,ub,lb,dim);fitness=zeros(1,pop);for i=1:pop    fitness(i)=fobj(X(i,:));endpBest=X;pBestFitness=fitness;[~,index]=min(fitness);gBestFitness=fitness(index);gBest=X(index,:);Xnew=X;fitnessNew=fitness;for t=1:maxIter    for i=1:pop        r1=rand(1,dim);        r2=rand(1,dim);        V(i,:)=V(i,:)+c1.*r1.*(pBest(i,:)-X(i,:))+c2.*r2.*(gBest-X(i,:));        V(i,:)=BoundaryCheck(V(i,:),vmax,vmin,dim);        Xnew(i,:)=X(i,:)+V(i,:);        fitnessNew(i)=fobj(Xnew(1,:));        if fitnessNew(i)&lt;pBestFitness(i)            pBest(i,:)=Xnew(i,:);            pBestFitness(i)=fitnessNew(i);        end        if fitnessNew(i)&lt;gBestFitness            gBestFitness=fitnessNew(i);            gBest=Xnew(i,:);        end    end    X=Xnew;    fitness=fitnessNew;    Best_Pos=gBest;    Best_fitness=gBestFitness;    IterCurve(t)=gBestFitness;endend\r\n\r\n需要解决的问题\r\n根据上述代码及文献，已经基本搞清楚PSO算法的编写过程和思路。现在需要解决的关键问题是如何设置变量内容、变量的数据结构和变量的上下界，即如何利用优化调度已经得到的数据通过PSO得到想要的参数拟合结果。\r\n根据所找文献，他将参数按照月份进行了划分，将非汛期的每一月都进行了参数拟合计算。所以提出以下思路：\r\n\r\n将每一月的入库流量和下泄流量作为输入参数，从1941-1990共50年，即初始种群数为50，先假设迭代次数为200。\r\n按照文献已经得到的参数，假设需要得到的三个参数为“粒子的最优坐标”，即三维PSO问题。\r\n\r\n明日任务\r\n完成变量数据结构设计，初步完成PSO代码。\r\n\r\nmatlab语法学习\r\n\r\nnum2str函数：将数字转换为字符数组\r\n\r\n训练数据准备\r\n按照列出的关系表达式，需要的初始数据有：当前时段的初始库容、时段入流，以及由优化调度得到的下泄流量。\r\n依据文献所给思路，编制50年各旬下泄流量、初始库容、时段入流的数据表，即36个50×3列数据表。\r\n训练数据使用\r\n每一旬得到的三组数据用于拟合数据参数，相当于二元一次线性非齐次方程组求“最接近的解。对于PSO，初始搜索点的位置及速度一般是在允许的范围内随机产生的，而对于函数提取，初始点的数据即为优化调度已得到的数据。\r\n类比可以推测，可以将时段入流和初始库容作为”初始搜索点“，即初始位置，将下泄流量作为速度。\r\n接上述观点，既然PSO不需要初始值，是不是优化调度获得的数据其实并不能直接用于参数估计，而是作为变量范围作为参考，迭代次数增加其实是在更加逼近范围内的最优值，而最优值也是由优化调度过程给出的。所以PSO是作为反映优化调度规律，便于调度计算而使用的算法。\r\n结果\r\n现得到36组参数数据，还需要带入具体流量数据进行测试。\r\n\r\n成果得出\r\n最后得到由调度函数调度的水位变化曲线和下泄流量曲线。\r\n修改的PSO算法代码如下：\r\n\r\n\r\nPSO算法（修改版）\r\n\r\n%pop——种群数量%dim——问题维度%ub——变量上界，[1,dim]矩阵%lb——变量下界，[1,dim]矩阵%fobj——适应度函数（指针）%MaxIter——最大迭代次数%Best_Pos——x的最佳值%Best_Score——最优适应度 for i = 1:36     for j = 1:50a = Data(j,3*i-1);b = Data(j,3*i);c = Data(j,3*i-2);pop=50;dim=2;vmax=[max(Data(:,3*i-1)),max(Data(:,3*i))];vmin=[min(Data(:,3*i-1)),min(Data(:,3*i))];ub=[2,2];lb=[0,0];maxIter=2000;fobj=@(X,a,b,c)fun(X,a,b,c);[Best_Pos,Best_fitness,IterCurve]=pso(pop,dim,ub,lb,fobj,vmax,vmin,maxIter,a,b,c);canshu(j,2*i-1) = Best_Pos(1);canshu(j,2*i) = Best_Pos(2);%&#123;figureplot(IterCurve,&#x27;r&#x27;,&#x27;linewidth&#x27;,2);grid on;disp([&#x27;求解得到的x1，x2是:&#x27;,num2str(Best_Pos(1)),&#x27; &#x27;,num2str(Best_Pos(2))]);disp([&#x27;最优解对应的函数:&#x27;,num2str(Best_fitness)]);%&#125;    end endfor i = 1:72        ave(i,1) = mean(canshu(:,i));    %ave(2*i,2) = mean(canshu(:,2*i));end %初始化粒子坐标和粒子速度function [X]=initialization(pop,ub,lb,dim)    for i=1:pop        for j=1:dim            X(i,j)=(ub(j)-lb(j))*rand()+lb(j);%在限定的          end     endend function fitness=fun(x,a,b,c)    fitness=sum(abs(c-x.*[a;b*100000000/(24*3600*10)]*[1;1]));end%检查初始数据点坐标位置是否在允许范围内function [X]=BoundaryCheck(X,ub,lb,dim)    for i=1:dim        if X(i)&gt;ub(i)            X(i)=ub(i);        end        if X(i)&lt;lb(i)            X(i)=lb(i);        end    endend function [Best_Pos,Best_fitness,IterCurve]=pso(pop,dim,ub,lb,fobj,vmax,vmin,maxIter,a,b,c)c1=2.0;c2=2.0;V=initialization(pop,vmax,vmin,dim);X=initialization(pop,ub,lb,dim);fitness=zeros(1,pop);for i=1:pop    fitness(i)=fobj(X(i,:),a,b,c);endpBest=X;pBestFitness=fitness;[~,index]=min(fitness);gBestFitness=fitness(index);gBest=X(index,:);Xnew=X;fitnessNew=fitness;for t=1:maxIter    for i=1:pop        r1=rand(1,dim);        r2=rand(1,dim);        V(i,:)=V(i,:)+c1.*r1.*(pBest(i,:)-X(i,:))+c2.*r2.*(gBest-X(i,:));        V(i,:)=BoundaryCheck(V(i,:),vmax,vmin,dim);        Xnew(i,:)=X(i,:)+V(i,:);        fitnessNew(i)=fobj(Xnew(1,:),a,b,c);        if fitnessNew(i)&lt;pBestFitness(i)            pBest(i,:)=Xnew(i,:);            pBestFitness(i)=fitnessNew(i);        end        if fitnessNew(i)&lt;gBestFitness            gBestFitness=fitnessNew(i);            gBest=Xnew(i,:);        end    end    X=Xnew;    fitness=fitnessNew;    Best_Pos=gBest;    Best_fitness=gBestFitness;    IterCurve(t)=gBestFitness;endend\r\n\r\n根据所提取的调度函数进行时段计算的代码如下：\r\n\r\n\r\n调度函数\r\n\r\n%%利用调度函数调度(1949)flag = 0;T = 24*3600*10/100000000;Vmax = 505;Zmax = 185;Vhs = zeros(36,1);Vhs(1,1) = 377.45;Zhs = zeros(36,1);Zhs(1,1) = 173.45;for t = 1:36Qhs(t,1) = ave(2*t-1,1)*Qrk(t,1)+ave(2*t,1)*Vhs(t,1)/T;Vhs(t+1,1) = Vhs(t,1) + (Qrk(t,1)-Qhs(t,1))*T;if Vhs(t+1,1) &gt; Vmax    Qhsqs(t+1,1) = (Vhs(t+1,1) - Vmax)/T;    Vhs(t+1,1) = Vmax;    Zhs(t+1,1) = Zmax;    Qhs(t,1) = Qrk(t,1)-(Vhs(t+1,1)-Vhs(t,1))/T;end%库容曲线约束Zhs(t+1,1) = Kurqx(Vhs(t+1,1));%当前时段末库容%发电水头约束[Hhs(t,1),kclhs(t,1)] = head(Qhs(t,1),Zhs(t,1));%输入下泄流量及上游水头Phs(t,1) = kclhs(t,1)*Qhs(t,1)*abs(Hhs(t,1)/10000);endfor i = 1:36    if Phs(i,1) &gt; 499        flag = flag + 1;    endendper = flag/36;yyaxis leftplot(1:37,Zhs(:,1));xlim([0 36]);ylim([145,190]);ylabel(&quot;水位/m&quot;);hold onyyaxis rightplot(1:36,Qhs(:,1));xlim([1,36]);ylabel(&quot;下泄流量/m³&quot;);xlabel(&quot;旬&quot;);title(&quot;1949年来流调度函数水位变化曲线&quot;);\r\n\r\n\r\n\r\n调度函数图像\r\n\r\n结果比较\r\n根据得出的数据对常规调度、优化调度、调度函数调度进行比较。\r\n选择比较的参数：平均水位、发电水头、下泄流量、弃水量、保证率和总发电量。\r\n经比较可以发现，三种方法的平均水位，平均下泄流量和发电水头差别不大，调度函数调度弃水较多，而常规调度后期水位很高，但前期为了符合调度图调度发电量较低，其中优化调度的结果较为实用。\r\n具体比较数据见下表。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n平均出力\r\n保证率\r\n平均水头\r\n平均水位\r\n平均下泄流量\r\n弃水量\r\n\r\n\r\n\r\n\r\n常规调度\r\n431.59\r\n55%\r\n91.69\r\n165.62\r\n17364.8\r\n0\r\n\r\n\r\n优化调度\r\n779.81\r\n95%\r\n55\r\n166\r\n17557.44\r\n0\r\n\r\n\r\n调度图\r\n445.4\r\n65%\r\n57\r\n168.77\r\n17441.272\r\n33039.45\r\n\r\n\r\n\r\n","tags":["课设"]},{"title":"水电站课设完成记录","url":"/2024/05/07/%E6%B0%B4%E7%94%B5%E7%AB%99%E8%AF%BE%E8%AE%BE%E5%AE%8C%E6%88%90%E8%AE%B0%E5%BD%95/","content":"任务：开展三峡水库中长期调度研究\r\n\r\n任务要求(4.14)\r\n进行水库长系列常规调度模拟计算（常规，非优化）\r\n\r\n一般采用常规调度图作为调度依据。\r\n\r\n进行水库长系列优化调度模拟计算\r\n\r\n约束：末水位为常规调度末水位\r\n目标函数：\r\n算法：\r\n\r\n需要通过惩罚系数调整发电保证率，得出惩罚系数、发电保证率和发电量三者的关系。\r\n在指定年份运行常规调度和优化调度的模型，获得结果并对比各特征值\r\n个性化数据\r\n\r\n计算初期水位：173.45m\r\n优化调度最小下泄流量：5690m³/s\r\n计划年：1975\r\n\r\n明日任务：完成任务一思路构建\r\n\r\nidea：根据95%的设计保证率进行年平均流量排频处理，输入P-Ⅲ型曲线代码得到相近年份，对照调度图进行常规调度模拟。\r\n\r\n\r\n使用方法（参照）(4.15)\r\n\r\n经验适线法\r\n点绘样本经验点据\r\n\r\n将实测资料由大到小排列，计算各年流量经验频率，然后将经验点据绘制在机率格纸上。\r\n\r\n估计参数的初值并绘制频率曲线\r\n\r\n采用矩法或其他方法，估计分布的3个参数，记为（\\(\\overline{x}\\), \\(C_{v}\\) , \\(C_{s}\\)\r\n),作为适线法的初值。根据该参数查P-Ⅲ型分布\\(\\Phi\\)值表，可以求得一组不同频率p对应的设计值\\(x_{p}\\)，即\r\n\\[\r\nx_{p}=\\overline{x}*\\left[1+C_{p}*\\Phi(p,C_{s})\\right] \\]\r\n根据(p,\\(x_{p}\\))绘制频率曲线（也称为理论频率曲线),并将此线画在绘有经验点据的机率格纸上。\r\n\r\n调整适线\r\n\r\n检查频率曲线与经验点据的拟合情况，若不理想，则调整参数（主要是调整\\(C_{s}\\),\\(C_{v}\\))，再重新计算频率曲线。\r\npoint\r\n在计算时需要根据已有的\\(\\Phi\\)值表读出不同\\(C_{v}\\),\\(C_{s}\\)下的\\(K_{p}\\)值进行择优选取曲线，当比值大于3时，则需要慎重考虑取值，可以反算前面的数据是否出现问题。\r\n选年\r\n经过排频分析，得出95%设计保证率选年可以选为1959年。\r\n\r\n\r\npaipinjieguotu\r\n\r\n任务一存在问题：\r\n已知发电量，如何确定水头\r\n由出力公式，\\(N=kQH\\)，由水力学关系，有k(H),h(Q),\\(H_{下}\\)(Q),故所有参数均为下泄流量Q的函数。\r\n如何使已知的一切数据表通过代码联动起来，实现导入运行即可导出\r\n\r\n为试算过程。\r\n\r\n需要解决程序如何在各阶段都能够线性插值，表格的使用顺序是什么样的，如何放置各阶段的约束条件。\r\n明日任务\r\n完成程序的基本调试。\r\n\r\n单时段常规调度程序(4.16)\r\n目前已经完成常规调度基本程序，需要进一步导入整个表格实现计算。以下为单个时段计算程序。\r\n思路存在问题：试算的结果无法进行及时的更新，无法确定具体的值。故不应将N设为试算结果评判标准，或应设置适当的Q的自增值。\r\n\r\n以下为上述思路代码\r\n\r\n\r\n代码一\r\n\r\n\r\n&#123;%%程序一Q = input(&quot;输入试算流量值：&quot;);hc = input(&quot;输入时段初水位&quot;);Nsj = input(&quot;输入实际出力&quot;);N = 0;while abs(N - Nsj) &gt;= 0.001%%插值下游水位流量曲线Q = Q + 0.01;for i = 1:29    if Q &gt;= ZO(i,1) &amp;&amp; Q &lt;= ZO(i+1,1)        hxy = ((ZO(i+1,2) - ZO(i,2))/(ZO(i+1,1) - ZO(i,1)))*(Q-ZO(i,1))+ZO(i,2);        break;    endend%%插值发电水头损失曲线for i = 1:13    if Q &gt;= Odh(i,1) &amp;&amp; Q &lt;= Odh(i+1,1)        hss = ((Odh(i+1,2) - Odh(i,2))/(Odh(i+1,1) - Odh(i,1)))*(Q-Odh(i,1))+Odh(i,2);        break;    end    if Q &gt;= Odh(15,1)        hss = ((Odh(15,2) - Odh(14,2))/(Odh(15,1) - Odh(14,1)))*(Q-Odh(14,1))+Odh(14,2);        break;    endend%%插值出力系数水头曲线H = hc - hss - hxy;for i = 1:5    if H &gt;= K(i,1) &amp;&amp; H &lt;= K(i+1,1)        kcl = ((K(i+1,2) - K(i,2))/(K(i+1,1) - K(i,1)))*(H-K(i,1))+K(i,2);        break;    end    if H &gt;= K(6,1)        kcl = ((K(6,2) - K(5,2))/(K(6,1) - K(5,1)))*(H-K(5,1))+K(5,2);        break;    endend%%计算出力N = kcl*Q*H/10000;end&#125;\r\n\r\n最终结果误差小于0.0001，故接受。\r\n尚未解决的问题\r\n\r\n如果初始流量值大于实际流量值，如何收敛到正确结果；\r\n初始填入的数据仍然需要通过读图读表得到，如何将其加入代码实现自动读图；\r\n在得出实际下泄流量后，还需要计算时段末水位和库容。库容还需设置边界条件(这里是很重要的数据边界条件)。\r\n\r\n明日任务\r\n完善程序细节，尽量解决上述问题。\r\n\r\n任务一终稿（有问题）(4.17)\r\n最终联动程序设计思路： - 根据已得出的时段初水位读出当前时段发电量； -\r\n根据入库流量假设出库流量，列入程序一进行试算； -\r\n利用试算结果得出时段末水位，得出下一时段计算初始条件，重复计算。\r\n需要逐步解决的问题：\r\n1.如何设置数组条件；\r\n2.如何在自定义函数中使用工作区变量；\r\n3.三峡汛限水位和死水位为同一高度，即在6月-9月之间无规定发电量，来多少泄多少发多少，如何设置程序具体功能；\r\n4.如何限制最大发电量，最大下泄流量，以及计算弃水\r\n目前已解决1、2、3问题\r\n遗留问题：如何确定下泄流量初值；如何限制最大发电量，最大下泄流量，以及计算弃水。\r\n\r\n\r\n代码二\r\n\r\n以下为主程序代码：\r\n&#123;%changguidiaodu.mfor j = 1:15hc = jieguo(j,4);jieguo(j,7) = NFun(hc,j);Nsj = jieguo(j,7);if jieguo(j,4) &gt; 145    Q = input(&quot;liuliang&quot;);else    Q = jieguo(j,2);endN = 0;while abs(N - Nsj) &gt;= 0.001%%插值下游水位流量曲线Q = Q + 0.01;[jieguo(j,6),N] = Nqfun(Q,hc);end%%计算出库流量、出库水量、时段末库容jieguo(j,10)= Q;jieguo(j,11) = Q*10*24*3600/100000000;jieguo(j,12)= jieguo(j,3) + jieguo(j,2) - jieguo(j,11);%%库容水位曲线%已知库容求水位for i = 1:55    if jieguo(j,12) &gt;= ZV(i,2) &amp;&amp; jieguo(j,12) &lt;= ZV(i+1,2)        jieguo(j,5) = ((ZV(i+1,1)-ZV(i,1))/(ZV(i+1,2)-ZV(i,2)))*(jieguo(j,12)-ZV(i,2))+ZV(i,1);    elseif jieguo(j,12) &gt; ZV(56,2)        jieguo(j,5) = ((ZV(56,1)-ZV(55,1))/(ZV(56,2)-ZV(55,2)))*(jieguo(j,12)-ZV(55,2))+ZV(55,1);    end    if jieguo(j,5) &lt; 145        jieguo(j,5) = 145;        Q = (jieguo(j,4)-jieguo(j,5))*100000000/(10*3600*24);        [jieguo(j,6),jieguo(j,7)] = Nqfun(Q,hc);    end    if jieguo(j,4) == jieguo(j,5) &amp;&amp; jieguo(j,5) == 145        Q = jieguo(i,2);        [jieguo(j,6),jieguo(j,7)] = Nqfun(Q,hc);    endendjieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);end&#125;\r\n读取调度图实际出力功能代码：\r\n&#123;%NFun.m%%利用调度图读取实际发电出力function result = NFun(x,y)for i = 1:6    if x &gt; diaodutu(y,i) &amp;&amp; x &lt; diaodutu(y,i+1)        result = 0.8*chuli(1,i);        break;    elseif x &lt; diaodutu(y,1)        result = chuli(1,6)*0.8;        break;    elseif x &gt; diaodutu(y,7)        result = chuli(1,1);        break;    endend&#125;\r\n以下为已知出力试算流量代码：\r\n&#123;%%计算发电量函数function [h,r] = Nqfun(x,y)for i = 1:29    if x &gt;= ZO(i,1) &amp;&amp; x &lt;= ZO(i+1,1)        hxy = ((ZO(i+1,2) - ZO(i,2))/(ZO(i+1,1) - ZO(i,1)))*(x-ZO(i,1))+ZO(i,2);        break;    endend%%插值发电水头损失曲线for i = 1:13    if x &gt;= Odh(i,1) &amp;&amp; x &lt;= Odh(i+1,1)        hss = ((Odh(i+1,2) - Odh(i,2))/(Odh(i+1,1) - Odh(i,1)))*(x-Odh(i,1))+Odh(i,2);        break;    end    if x &gt;= Odh(15,1)        hss = ((Odh(15,2) - Odh(14,2))/(Odh(15,1) - Odh(14,1)))*(x-Odh(14,1))+Odh(14,2);        break;    endend%%插值出力系数水头曲线h = y - hss - hxy;for i = 1:5    if h &gt;= K(i,1) &amp;&amp; h &lt;= K(i+1,1)        kcl = ((K(i+1,2) - K(i,2))/(K(i+1,1) - K(i,1)))*(h-K(i,1))+K(i,2);        break;    end    if h &gt;= K(6,1)        kcl = ((K(6,2) - K(5,2))/(K(6,1) - K(5,1)))*(h-K(5,1))+K(5,2);        break;    endend%%计算出力r = kcl*x*h/10000;&#125;\r\n\r\n存在问题\r\n\r\n全功能代码过于复杂，并不容易调试，现尝试分函数块逐情况处理。\r\n\r\n明日任务\r\n优化处理任务一程序，完善功能。\r\n\r\n课后新思路(4.19)\r\n\r\n155m为非汛期最低水位，即真正的死水位，故在枯水期调度时水位不能低于155；\r\n可以考虑对每一时段进行以电定水试算（查阅水文水利计算课本）\r\n\r\n存在问题：\r\n\r\n两个主要功能函数存在循环嵌套的问题，需要细改\r\n\r\n以下为新代码：\r\n\r\n\r\n代码三\r\n\r\n&#123;%changguidiaodu%for j = 1:15hc = jieguo(j,4);jieguo(j,7) = NFun(hc,j);Nsj = jieguo(j,7);if jieguo(j,4) &gt; 145    Q = input(&quot;liuliang&quot;);    N = 0;while abs(N - Nsj) &gt;= 0.001%%插值下游水位流量曲线Q = Q + 0.01;[jieguo(j,5),jieguo(j,6),N] = Nqfun(Q,hc,jieguo(j,2));%&#123;if jieguo(j,5) &lt;= 145        [jieguo(j,5),jieguo(j,6),N] = ZVend(jieguo(j,12),jieguo(j,4),jieguo(j,2),jieguo(j,5));        break;end%&#125;endelse    Q = jieguo(j,2);end%%计算出库流量、出库水量、时段末库容jieguo(j,10)= Q;jieguo(j,11) = Q*10*24*3600/100000000;jieguo(j,12)= jieguo(j,3) + jieguo(j,2) - jieguo(j,11);%%库容水位曲线%已知库容求时段末水位jieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);%end&#125;&#123;%Nqfun%%计算发电量函数function [h,h51,r] = Nqfun(x,y,z)%插值下游水位流量曲线for i = 1:29    if x &lt; ZO(1,1)        hxy = ((ZO(1,2) - ZO(2,2))/(ZO(1,1) - ZO(2,1)))*(ZO(1,1)-x)+ZO(2,2);        break;    elseif x &gt;= ZO(i,1) &amp;&amp; x &lt;= ZO(i+1,1)        hxy = ((ZO(i+1,2) - ZO(i,2))/(ZO(i+1,1) - ZO(i,1)))*(x-ZO(i,1))+ZO(i,2);        break;    endend%%插值发电水头损失曲线for i = 1:13     if x &lt; Odh(1,1)        hss = ((Odh(1,2) - Odh(2,2))/(Odh(1,1) - Odh(2,1)))*(Odh(1,1)-x)+Odh(2,2);        break;     elseif x &gt;= Odh(i,1) &amp;&amp; x &lt;= Odh(i+1,1)        hss = ((Odh(i+1,2) - Odh(i,2))/(Odh(i+1,1) - Odh(i,1)))*(x-Odh(i,1))+Odh(i,2);        break;    end    if x &gt;= Odh(15,1)        hss = ((Odh(15,2) - Odh(14,2))/(Odh(15,1) - Odh(14,1)))*(x-Odh(14,1))+Odh(14,2);        break;    endend%%插值出力系数水头曲线h51 = y - hss - hxy;for i = 1:5    if h51 &lt; K(1,1)        kcl = ((K(1,2) - K(2,2))/(K(1,1) - K(2,1)))*(K(1,1)-h51)+K(2,2);        break;    elseif h51 &gt;= K(i,1) &amp;&amp; h51 &lt;= K(i+1,1)        kcl = ((K(i+1,2) - K(i,2))/(K(i+1,1) - K(i,1)))*(h51-K(i,1))+K(i,2);        break;    end    if h51 &gt;= K(6,1)        kcl = ((K(6,2) - K(5,2))/(K(6,1) - K(5,1)))*(h51-K(5,1))+K(5,2);        break;    endend[h,h51,~] = ZVend(x*10*24*3600,y,z);    %%计算出力r = kcl*x*h51/10000;&#125;&#123;%ZVend%%求时段末水位function [h5,h6,N] = ZVend(x,y,z)%x为当前计算下的时段末库容，y为当前时段的初始水位,z为本时段来流流量,w为当前计算所得时段末水位for i = 1:55    if x &gt;= ZV(i,2) &amp;&amp; x &lt;= ZV(i+1,2)        w = ((ZV(i+1,1)-ZV(i,1))/(ZV(i+1,2)-ZV(i,2)))*(x-ZV(i,2))+ZV(i,1);    elseif x &gt; ZV(56,2)        w = ((ZV(56,1)-ZV(55,1))/(ZV(56,2)-ZV(55,2)))*(x-ZV(55,2))+ZV(55,1);    end    if w &lt; 145        Q = (y-145)*100000000/(10*3600*24);        [h6,N] = Nqfun(Q,y,z);            elseif y == w &amp;&amp; w == 145        Q = z;        [h6,N] = Nqfun(Q,y,z);            endend&#125;\r\n\r\n现在出现的问题关键在于想实现全自动读取数据，也许有贪心不足的情况，接下来的任务，还是继续跑第一次的程序，手动算出一组数据再进行改进。目前思路出现了一些循环论证的问题，需要搞清楚怎么把所需要试算的数据拆开再循环，应该是逻辑本身有问题，下次推进的时候先解决一下整个计算的试算步骤。\r\n明日任务\r\n解决函数逻辑问题。\r\n\r\n今日无具体推进。(4.20)\r\n上课间隙简单跑了一下昨天最后的思路，发现一开始就出现了问题，因为水头本身很低，所以最后循环出来的时段末水位甚至成为了负值，这就导致以电定水的循环无法结束，故回到最初的思路，即在计算完出力后在循环内立即计算时段末水位，若不低于145，则继续迭代流量值，若低于145，则转为来多少发多少，计算结束后直接退出循环。\r\n这里也是上文所述的出现了循环嵌套的问题，今天所产生的新思路为，将正常插值计算时段末水位和来多少发多少计算时段末水位分开成两个函数进行使用，在出现水位过低的情况时，调用后者，并在计算完成后直接退出循环。\r\n仍需实践探索。\r\n明日任务\r\n争取改善时段循环的关键代码。\r\n\r\n正式完成水电站常规调度。最终代码如下：(4.22)\r\n\r\n\r\n代码四\r\n\r\n主程序代码：\r\n&#123;changguidiaodu.mfor j = 1:36hc = jieguo(j,4);jieguo(j,7) = NFun(hc,j);Nsj = jieguo(j,7);Q = 3000;N = 0;f = 0;while abs(N - Nsj) &gt;= 0.001 &amp;&amp; f == 0%%插值下游水位流量曲线Q = Q + 0.01;[jieguo(j,6),jieguo(j,5),N,f] = Nqfun(Q,hc,jieguo(j,2),jieguo(j,3));%试算找出最合适的值if f == 1    jieguo(j,7) = N;endend%%计算出库流量、出库水量、时段末库容%计算时段末库容for i = 1:55    if jieguo(j,5) &gt;= ZV(i,1) &amp;&amp; jieguo(j,5) &lt;= ZV(i+1,1)        V = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(jieguo(j,5)-ZV(i,1))+ZV(i,2);    endend%计算出库水量、出库流量jieguo(j,12)= V;jieguo(j,10)= jieguo(j,2)+jieguo(j,3)-V;jieguo(j,11) = jieguo(j,10)*10*24*3600/100000000;jieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);endplot(1:36,jieguo(1:36,5));ylim([130,175]);&#125;\r\n计算当前水位设计出力代码：\r\n&#123;NFun.m%%利用调度图读取设计发电出力function result = NFun(x,y)for i = 1:6    if x &gt;= diaodutu(y,i+1) &amp;&amp; x &lt;= diaodutu(y,i)        result = chuli(1,i);        break;    elseif x &lt;= diaodutu(y,1)        result = chuli(1,6);        break;    elseif x &gt;= diaodutu(y,7)        result = chuli(1,1);        break;    endend&#125;\r\n计算实际发电出力\r\n&#123;Nqfun.m%%计算发电量函数function [h51,h,r,flg] = Nqfun(x,y,z,v)%下泄流量、初水位、入库水量、时段初水量[h51,kcl] = head(x,y);%%计算出力r = kcl*x*h51/10000;%计算时段末水位h = ZVendnormal(z+v-x*10*24*3600/100000000);flg = 0;if h&lt;=145    h = 145;    for i = 1:55        if y &gt;= ZV(i,1) &amp;&amp; y &lt;= ZV(i+1,1)            w = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(y-ZV(i,1))+ZV(i,2);        end    end    x = z+v-w;    [h51,kcl] = head(x,y);    r = kcl*x*h51/10000;    flg = 1;endend&#125;\r\n计算正常情况下时段末水位： &#123;ZVendnormal.mfunction w = ZVendnormal(x)%x为时段末库容for i = 1:55    if x &gt;= ZV(i,2) &amp;&amp; x &lt;= ZV(i+1,2)        w = ((ZV(i+1,1)-ZV(i,1))/(ZV(i+1,2)-ZV(i,2)))*(x-ZV(i,2))+ZV(i,1);    elseif x &gt; ZV(56,2)        w = ((ZV(56,1)-ZV(55,1))/(ZV(56,2)-ZV(55,2)))*(x-ZV(55,2))+ZV(55,1);    endend&#125;\r\n计算发电水头： &#123;head.m%%水头计算函数function [h51,kcl] = head(x,y)%下泄流量,时段初水位%插值下游水位流量曲线for i = 1:29    if x &lt; ZO(1,1)        hxy = ((ZO(1,2) - ZO(2,2))/(ZO(1,1) - ZO(2,1)))*(ZO(1,1)-x)+ZO(2,2);        break;    elseif x &gt;= ZO(i,1) &amp;&amp; x &lt;= ZO(i+1,1)        hxy = ((ZO(i+1,2) - ZO(i,2))/(ZO(i+1,1) - ZO(i,1)))*(x-ZO(i,1))+ZO(i,2);        break;    endend%%插值发电水头损失曲线for i = 1:13     if x &lt; Odh(1,1)        hss = ((Odh(1,2) - Odh(2,2))/(Odh(1,1) - Odh(2,1)))*(Odh(1,1)-x)+Odh(2,2);        break;     elseif x &gt;= Odh(i,1) &amp;&amp; x &lt;= Odh(i+1,1)        hss = ((Odh(i+1,2) - Odh(i,2))/(Odh(i+1,1) - Odh(i,1)))*(x-Odh(i,1))+Odh(i,2);        break;    end    if x &gt;= Odh(15,1)        hss = ((Odh(15,2) - Odh(14,2))/(Odh(15,1) - Odh(14,1)))*(x-Odh(14,1))+Odh(14,2);        break;    endend%%插值出力系数水头曲线h51 = y - hss - hxy;for i = 1:5    if h51 &lt; K(1,1)        kcl = ((K(1,2) - K(2,2))/(K(1,1) - K(2,1)))*(K(1,1)-h51)+K(2,2);        break;    elseif h51 &gt;= K(i,1) &amp;&amp; h51 &lt;= K(i+1,1)        kcl = ((K(i+1,2) - K(i,2))/(K(i+1,1) - K(i,1)))*(h51-K(i,1))+K(i,2);        break;    end    if h51 &gt;= K(6,1)        kcl = ((K(6,2) - K(5,2))/(K(6,1) - K(5,1)))*(h51-K(5,1))+K(5,2);        break;    endend&#125;\r\n\r\n最终得到枯水年枯水期发电水位变化曲线为：\r\n如图，在全年除汛期应正常维持在死水位外，其他时期的水头对发电来说过低，整体发电量很少。所选择的枯水年来水极少是一方面的原因，还有一方面，即直接使用调度图可能会导致竭泽而渔，彻底不给后面的来水情况做预备。\r\n\r\n\r\nshuiweibianhuatu\r\n\r\n接下来的任务是在已知初水位末水位的情况下，在汛限水位的约束下对发电和水位曲线进行优化调度。即任务二：\r\n进行水库长系列优化调度模拟计算\r\n\r\n约束：末水位为常规调度末水位\r\n目标函数：\r\n算法：\r\n\r\n需要通过惩罚系数调整发电保证率，得出惩罚系数、发电保证率和发电量三者的关系。\r\n明日任务\r\n初步寻找所使用的优化调度方法和方程建立思路。\r\n\r\n(4.23)\r\n上午上课发现之前计算的初始水位选的有点太低，所以回来又改了一下常规调度的代码，矫正了一些参数的输出，变动不大，就不放出来了。\r\n晚上在查找优化调度使用的方法，在多约束又多阶段的情况下，决定使用微分动态规划进行优化计算。需要具体学习一下微分动态规划的理论和建立方程的方法，作为明天的任务。\r\n查到有关微分动态规划理论的网址如下：\r\n\r\nhttps://www.jianshu.com/p/f22de42327b4\r\nhttps://zhuanlan.zhihu.com/p/629149697\r\n\r\n\r\n(4.24)\r\n昨晚观察表格发现后三个月来水并不少，所以决定今天首先把时段末水位重新蓄回正常蓄水位，水位蓄高之后发电量与之前相比也大了很多。修改的主程序代码如下，其余功能函数没有发生改变：\r\n\r\n\r\n代码五\r\n\r\n&#123;%%前24旬调度计算for j = 1:24hc = jieguo(j,4);jieguo(j,7) = NFun(hc,j);Nsj = jieguo(j,7);Q = 3000;N = 0;f = 0;while abs(N - Nsj) &gt;= 0.001 &amp;&amp; f == 0%%插值下游水位流量曲线Q = Q + 0.01;[jieguo(j,6),jieguo(j,5),N,f] = Nqfun(Q,hc,jieguo(j,2),jieguo(j,3));%试算找出最合适的值if f == 1    jieguo(j,7) = N;endend%%计算出库流量、出库水量、时段末库容%计算时段末库容for i = 1:55    if jieguo(j,5) &gt;= ZV(i,1) &amp;&amp; jieguo(j,5) &lt;= ZV(i+1,1)        V = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(jieguo(j,5)-ZV(i,1))+ZV(i,2);    endend%计算出库水量、出库流量jieguo(j,12)= V;jieguo(j,11)= jieguo(j,2)+jieguo(j,3)-V;jieguo(j,10) = jieguo(j,11)*100000000/(10*24*3600);jieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);end%%后12旬（蓄水至175）jieguo(36,12) = 0;Q = 3000;while abs(393-jieguo(36,12))&gt;0.01Q = Q+0.01;for j = 25:36hc = jieguo(j,4);%&#123;jieguo(j,7) = NFun(hc,j);Nsj = jieguo(j,7);%&#125;[jieguo(j,6),jieguo(j,5),jieguo(j,7),f] = Nqfun(Q,hc,jieguo(j,2),jieguo(j,3));%试算找出最合适的值if f == 1    jieguo(j,7) = N;end%&#125;%%计算出库流量、出库水量、时段末库容%计算时段末库容for i = 1:55    if jieguo(j,5) &gt;= ZV(i,1) &amp;&amp; jieguo(j,5) &lt;= ZV(i+1,1)        V = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(jieguo(j,5)-ZV(i,1))+ZV(i,2);    endend%计算出库水量、出库流量jieguo(j,12)= V;jieguo(j,11)= jieguo(j,2)+jieguo(j,3)-V;jieguo(j,10) = jieguo(j,11)*100000000/(10*24*3600);jieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);endendyyaxis leftplot(1:36,jieguo(1:36,5));xlim([1 36]);ylim([145,185]);hold onyyaxis rightplot(1:36,jieguo(1:36,10));xlim([1,36]);%&#125;&#125;\r\n\r\n明日任务\r\n首先尝试使用最基本的动态规划解决问题。先建立好动态规划方程并设置计算的数据结构。\r\n\r\n（5.6）\r\n首先建立逆序递推方程\r\n1.阶段与阶段变量\r\n根据中长期规划，按旬划分为36个阶段，以t表示阶段变量，则t为面临时段，t+1~T为余留时期；\r\n2.状态变量\r\n选择水库蓄水量为状态变量，记\\(V(t)\\)为t时段初蓄水量；\r\n3.决策变量\r\n取水电站发电引用流量\\(Qfd(t)\\)为决策变量；\r\n4.状态转移方程\r\n即水量平衡方程，\\(V(t+1) = V(t) +\r\n[Q_{rk}(t) - Q_{fd}(t) - Q_{qs}(t)]*\\Delta T\\);\r\n5.指标函数\r\n&#123;output(t) = K * Qfd(t) * H(t);if output(t) &gt;= Pb    Pcl(t) = output(t);else    Pcl(t) = output(t) + b*(output(t)-Pb);end&#125;\r\n6.递推方程\r\n\\[\\left\\{\r\n\\begin{array}\r\nPbest(t+1) = max(Pcl(t)+Pbest(t)); \\\\\r\nV(t+1) = V(t) + (Qrk(t)-Qfd(t)-Qqs(t))*T;\r\n\\end{array}\r\n\\right.\\]\r\n7.约束条件\r\n\r\n上下游水头差计算（函数约束）\r\n水电站预想出力限制（范围约束）\r\n水电站最大过流能力限制（范围约束）\r\n综合利用约束（范围约束）\r\n水库水量平衡（函数约束）\r\n库容曲线约束（函数约束）\r\n库水位或库蓄水量约束（范围约束）\r\n下游水位流量关系约束（值约束）\r\n\r\n即得如下代码：\r\n\r\n\r\n代码六\r\n\r\n&#123;%%水库优化调度代码%生态流量限制Qst = input(&quot;最小生态流量为&quot;);%本次计算为5690T = 12*24*3600/100000000;%时段间隔Pb = 499;%保证出力Z = zeros(36,1);V = zeros(36,1);output = zeros(36,1);Qfd = zeros(36,1);yxcl = zeros(36,1);xxnl = zeros(36,1);Z(1,1) = 175;Z(36,1) = 175;V(1,1) = 393;output(1,1) = 0;Qfd(1,1) = 6753;yxcl(1,1) = 1;xxnl(1,1) = Omax(12,2);Pbest(1,1) = 0;for t = 1:50if output(t,1) &lt; yxcl(t,1) &amp;&amp; Qfd(t,1) &lt; xxnl(t,1) &amp;&amp; Qfd(t,1) &gt;= Qst &amp;&amp; Z(t,1) &gt;= 145 &amp;&amp; Z(1,1)==175 &amp;&amp; Z(36,1)== 175%%约束条件编制%发电水头约束[H(t,1) K] = head(Qfd(t,1),Z(t,1));%输入下泄流量及上游水头%水电站预想出力限制yxcl(t,1) = Yuxcl(H(t));%输入当前水头%水电站最大过流能力限制xxnl(t,1) = Xiaxnl(Z(t,1));%输入当前上游水位%建立状态转移方程V(t+1,1) = V(t,1) + (Qrk(t,1)-Qfd(t,1))*T;%库容曲线约束Z(t+1,1) = Kurqx(V(t+1));%当前时段末水位%指标函数（含惩罚函数）output(t,1) = K * Qfd(t,1) * H(t,1);if output(t,1) &gt;= Pb    Pcl(t,1) = output(t,1);else    Pcl(t,1) = output(t,1) + b*(output(t,1)-Pb);end%递推方程Pbest(t+1,1) = max(Pcl(t,1)+Pbest(t,1));endif output(t,1) &gt; yxcl(t,1)    output(t,1) = yxcl(t,1);endif Qfd(t,1) &gt; xxnl(t,1)     Qfd(t,1) = xxnl(t,1);endif Qfd(t,1) &lt; Qst     Qfd(t,1) = Qst;endif Z(t,1) &lt; 145    Z(t,1) = 145;     endZ(1,1) =175;Z(36,1) = 175;end&#125;其中，有最大下泄能力计算函数：​~~~matlab&#123;function q = Xiaxnl(x)%当前计算期上游水位for i = 1:11    if x &gt;= Omax(i,1) &amp;&amp; x &lt;= Omax(i+1,1)        q = ((Omax(i+1,2)-Omax(i,2))/(Omax(i+1,1)-Omax(i,1)))*(x-Omax(i,1))+Omax(i,2);    endend&#125;\r\n预想出力限制计算函数：\r\n&#123;function Nyx = Yuxcl(x)%当前计算期出力水头for i = 1:17    if x &gt;= Nmax(i,1) &amp;&amp; x &lt;= Nmax(i+1,1)        Nyx = ((Nmax(i+1,2)-Nmax(i,2))/(Nmax(i+1,1)-Nmax(i,1)))*(x-Nmax(i,1))+Nmax(i,2);    endend&#125;\r\n库容曲线约束计算函数：\r\n&#123;%%库容曲线约束function z = Kurqx(x)%下一计算期的初始库容for i = 1:55    if x &gt;= ZV(i,2) &amp;&amp; x &lt;= ZV(i+1,2)        z = ((ZV(i+1,1)-ZV(i,1))/(ZV(i+1,2)-ZV(i,2)))*(x-ZV(i,2))+ZV(i,1);    endend&#125;\r\n\r\n写出计算方程后，出现如下问题\r\n\r\n问题1：只能计算下一个时段，如何实现全时段计算？如何将一个时段内的计算初始条件划分为多个段进行计算？如何设置数组？如何设置循环次数？\r\n问题2：约束条件很多，如何写入程序？写在哪里？如何实现变量约束条件内的改变？\r\n\r\n\r\n\r\n代码七\r\n\r\n&#123;%%水库优化调度代码%间隔数n = 51;%生态流量限制Qst = 5690;%设置惩罚系数b = 0.5;T = 12*24*3600/100000000;%时段间隔Pb = 499;%保证出力V = zeros(n,36);output = zeros(n,36);Qfd = zeros(n,1);yxcl = zeros(n,1);xxnl = zeros(n,1);V(1,1) = 393;Qfd(1,1) = Qst;yxcl(1,1) = 1;xxnl(1,1) = Omax(12,2);Pbest(1,1) = 0;flg = 0;%标志位%优化计算过程for j = 1:14for t = 1:51if output(t,j) &lt; yxcl(t,1) &amp;&amp; Qfd(t,1) &lt; xxnl(t,1) &amp;&amp; Qfd(t,1) &gt;= Qst &amp;&amp; Z(t,j) &gt;= 145 &amp;&amp; V(t,1) &lt;= 393 &amp;&amp; V(t,1) &gt;= 171.5Z(t,15) = 145;%发电水头约束[H(t,1) K] = head(Qfd(t,1),(Z(t,j)+Z(t,j+1))/2);%输入下泄流量及上游水头%指标函数（含惩罚函数）output(t+1,1) = K * Qfd(t,1) * H(t,1)/10000;if output(t+1,1) &gt;= Pb    Pcl(t+1,1) = output(t+1,1);else    Pcl(t+1,1) = output(t+1,1) + b*(output(t+1,1)-Pb);end%递推方程Pbest(t+1,1) = max(Pcl(t,1)+Pbest(t,1));Qfd(t+1,1) = Qfd(t,1)+0.1;%%约束条件编制%水电站预想出力限制yxcl(t+1,1) = Yuxcl(H(t,1));%输入当前水头%水电站最大过流能力限制xxnl(t+1,1) = Xiaxnl(Z(t,1));%输入当前上游水位%建立状态转移方程V(t+1,1) = V(t,1) + (Qrk(j,1)-Qfd(t,1))*T;%库容曲线约束Z(t,j+1) = Kurqx(V(t+1,1));%当前时段末水位flg = flg+1;endendend&#125;\r\n\r\n以上代码基本解决上述问题，出现新问题：\r\n\r\n为什么总是跳出循环？如何解决？\r\n为什么计算结果里依然出现了不符合约束条件的值？\r\n如何确保最后一个水位为145？[增加if语句，若j=15则进入，单独计算流量值]\r\n\r\n明日任务\r\n解决上述问题。\r\n\r\n（5.7） ## 问题：在哪里以及如何改变Q？\r\n解决：Qfd为事先定义的数组。现在将约束条件变为if语句，加入Qfd初值设置，即将Q设为决策变量，相比于课堂所讲方法，他将水位作为决策变量。\r\n问题：出现维数灾，不知道需要计算多久。\r\n\r\n\r\n代码八\r\n\r\n&#123;%%水库优化调度代码Qst = 5690;%生态流量限制b = 0.5;%设置惩罚系数T = 12*24*3600/100000000;%时段间隔Pb = 499;%保证出力Pcl = zeros(51,36);Pbest = zeros(51,36);t = 1;flg = 0;%标志位%优化计算过程for j = 1:15Z(1,1) = 175;Z(1,15) = 145;%%试算发电流量while t &lt;= 51flg = flg+1;%循环标志位for i = 1:15000%下泄流量范围l = length(Qst:1:Qst+15000);Qfd(1:l,j) = (Qst:1:Qst+15000)&#x27;;%建立状态转移方程V(t+1,j) = V(t,j) + (Qrk(j,1)-Qfd(t,j))*T;if V(t+1,1) &gt; 393 || V(t+1,1) &lt; 171.5    continue;end%库容曲线约束Z(1,j+1) = Kurqx(V(t+1,1));%当前时段末水位if Z(1,j+1) &lt; 145 || Z(1,j+1) &gt; 175    continue;end%发电水头约束[H(t,1) K] = head(Qfd(i,j),Z(1,j));%输入下泄流量及上游水头%指标函数（含惩罚函数）output(t+1,j) = K * Qfd(i,j) * H(t,1)/10000;if output(t,j) &gt; yxcl(t,1)    continue;endif output(t+1,j) &gt;= Pb    Pcl(t+1,j) = output(t+1,j);else    Pcl(t+1,j) = output(t+1,j) + b*(output(t+1,j)-Pb);end%递推方程Pbest(t+1,j) = max(Pcl(t,j)+Pbest(t,j));%%约束条件编制%水电站预想出力限制yxcl(t+1,1) = Yuxcl(H(t,1));%输入当前水头%水电站最大过流能力限制xxnl(t+1,1) = Xiaxnl(Z(1,j));%输入当前上游水位t = t+1;break;endendend&#125;\r\n\r\n明日任务：等待结果。\r\n\r\n（5.8）\r\n发现问题：Qfd的改变过于死板，导致程序会陷入一个时段的死循环\r\n完成优化调度，代码如下：\r\n\r\n\r\n代码九\r\n\r\n&#123;%%水库优化调度代码Qst = 5690;%生态流量限制b = 0.5;%设置惩罚系数T = 12*24*3600/100000000;%时段间隔Pb = 499;%保证出力V(1,1) = 393;flg = 0;%标志位Pbest = zeros(15000,15);%优化计算过程for j = 1:15Z1(1,1) = 175;%下泄流量范围l = length(Qst:1:Qst+15000);Qfd(1:l,j) = (Qst:1:Qst+15000)&#x27;;flg = flg+1;%循环标志位for i = 1:15000if V(1,j) &lt; 171.5    Qfd(i,j) = Qfd(i-1,j);    break;end%%约束条件编制%发电水头约束[H(i,1) K] = head(Qfd(i,j),Z1(1,j));%输入下泄流量及上游水头%水电站预想出力限制yxcl(i,1) = Yuxcl(H(i,1));%输入当前水头%水电站最大过流能力限制xxnl(i,1) = Xiaxnl(Z1(1,j));%输入当前上游水位%指标函数（含惩罚函数）output(i,j) = K * Qfd(i,j) * H(i,1)/10000;if output(i,j) &gt; yxcl(i,1)    continue;endif output(i,j) &gt;= Pb    Pcl(i,j) = output(i,j);else    Pcl(i,j) = output(i,j) + b*(output(i,j)-Pb);end%递推方程Pbest(i+1,j) = max(Pcl(i,j)+Pbest(i,j));end%建立状态转移方程V(1,j+1) = V(1,j) + (Qrk1(j,1)-Qfd(1,j))*T;%库容曲线约束Z1(1,j+1) = Kurqx(V(1,j+1));%当前时段末水位Z1(1,16) = 145;end%优化计算过程2V(1,1) = 171.5;for j = 1:9Z2(1,1) = 145;%下泄流量范围l = length(Qst:1:Qst+15000);Qfd(1:l,j) = (Qst:1:Qst+15000)&#x27;;flg = flg+1;%循环标志位for i = 1:15000if V(1,j) &lt; 171.5    Qfd(i,j) = Qfd(i-1,j);    break;end%%约束条件编制%发电水头约束[H(i,1) K] = head(Qfd(i,j),Z2(1,j));%输入下泄流量及上游水头%水电站预想出力限制yxcl(i,1) = Yuxcl(H(i,1));%输入当前水头%水电站最大过流能力限制xxnl(i,1) = Xiaxnl(Z2(1,j));%输入当前上游水位%指标函数（含惩罚函数）output(i,j) = K * Qfd(i,j) * H(i,1)/10000;if output(i,j) &gt; yxcl(i,1)    continue;endif output(i,j) &gt;= Pb    Pcl(i,j) = output(i,j);else    Pcl(i,j) = output(i,j) + b*(output(i,j)-Pb);end%递推方程Pbest(i+1,j) = max(Pcl(i,j)+Pbest(i,j));end%建立状态转移方程V(1,j+1) = V(1,j) + (Qrk2(j,1)-Qfd(1,j))*T;%库容曲线约束Z2(1,j+1) = Kurqx(V(1,j+1));%当前时段末水位Z2(1,16) = 175;endfor i=1:15    endZ(i,1) = Z1(1,i);endfor i = 16:27    endZ(i,1) = 145;endfor i = 28:36    endZ(i,1) = Z2(1,i-27);endplot(1:36,endZ(1:36,1));xlim([1 36])ylim([145 185])&#125;\r\n\r\n得到水位变化如下图：\r\n\r\n\r\nimage-20240508161239028\r\n\r\n使用1975年数据进行演算，得到优化调度保证率为77%，全年发电量13562.95wkW,常规调度保证率为45%，全年发电处理7916.28wkW,有显著的优化效果，可见调度图调度的保守性。\r\n\r\n（5.9）\r\n需要在程序中加入弃水计算部分，经过查找资料，得到弃水的出现条件是在水头一定的条件下电站出力不得大于水电站的预想出力，若大于，则多余水量为弃水.代码如下：\r\n\r\n\r\n代码十\r\n\r\n&#123;%%前27旬调度计算for j = 1:27h = 0;hc = jieguo(j,4);jieguo(j,7) = NFun(hc,j);Nsj = jieguo(j,7);Q = 3000;N = 0;f = 0;while abs(N - Nsj) &gt;= 1 &amp;&amp; f == 0%%插值下游水位流量曲线Q = Q + 1;[jieguo(j,6),jieguo(j,5),N,f] = Nqfun(Q,hc,jieguo(j,2),jieguo(j,3));%试算找出最合适的值if f == 1    jieguo(j,7) = N;end%%计算弃水Q1 = 1500;while jieguo(j,7) &gt; Yuxcl(jieguo(j,6))    jieguo(j,7) = Yuxcl(jieguo(j,6));    while abs(N - Yuxcl(jieguo(j,6))) &gt;= 10    %%插值下游水位流量曲线    Q1 = Q1 + 1;    [jieguo(j,6),h,N,f] = Nqfun(Q1,hc,jieguo(j,2),jieguo(j,3));%试算找出最合适的值    endend%&#125;end%%计算出库流量、出库水量、时段末库容%计算时段末库容for i = 1:55    if jieguo(j,5) &gt;= ZV(i,1) &amp;&amp; jieguo(j,5) &lt;= ZV(i+1,1)        V = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(jieguo(j,5)-ZV(i,1))+ZV(i,2);    endend%计算有弃水情况下的发电流量if h &gt; 0for i = 1:55    if h &gt;= ZV(i,1) &amp;&amp; h &lt;= ZV(i+1,1)        Vq = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(h-ZV(i,1))+ZV(i,2);    endendjieguo(j,9) = (V - Vq)*100000000/(10*24*3600);else    jieguo(j,9) = 0;end%计算出库水量、出库流量jieguo(j,12)= V;jieguo(j,11)= jieguo(j,2)+jieguo(j,3)-V;jieguo(j,10) = jieguo(j,11)*100000000/(10*24*3600);jieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);end%%后9旬（蓄水至175）jieguo(36,12) = 0;Q = 3000;while abs(393-jieguo(36,12))&gt;0.01Q = Q+0.01;for j = 27:36hc = jieguo(j,4);[jieguo(j,6),jieguo(j,5),jieguo(j,7),f] = Nqfun(Q,hc,jieguo(j,2),jieguo(j,3));%试算找出最合适的值if f == 1    jieguo(j,7) = N;end%&#125;%%计算出库流量、出库水量、时段末库容%计算时段末库容for i = 1:55    if jieguo(j,5) &gt;= ZV(i,1) &amp;&amp; jieguo(j,5) &lt;= ZV(i+1,1)        V = ((ZV(i+1,2)-ZV(i,2))/(ZV(i+1,1)-ZV(i,1)))*(jieguo(j,5)-ZV(i,1))+ZV(i,2);    endend%计算出库水量、出库流量jieguo(j,12)= V;jieguo(j,11)= jieguo(j,2)+jieguo(j,3)-V;jieguo(j,10) = jieguo(j,11)*100000000/(10*24*3600);jieguo(j,8) = jieguo(j,7)*10*24/10000;jieguo(j+1,3) = jieguo(j,12);jieguo(j+1,4) = jieguo(j,5);endendyyaxis leftplot(1:36,jieguo(1:36,5));xlim([1 36]);ylim([145,185]);ylabel(&quot;水位/m&quot;);hold onyyaxis rightplot(1:36,jieguo(1:36,10));xlim([1,36]);ylabel(&quot;下泄流量/m³&quot;);xlabel(&quot;旬&quot;);title(&quot;1975年来流常规调度水位变化曲线&quot;);&#125;\r\n\r\n需要加入惩罚系数和发电保证率之间的关系的计算，代码如下：\r\n\r\n\r\n代码十一\r\n\r\n%%水库优化调度代码Qst = 5690;%生态流量限制T = 12*24*3600/100000000;%时段间隔Pb = 499;%保证出力V(1,1) = 393;flg = 0;%标志位m = 0;%计算保证率指标Pbest = zeros(15000,15);for c = 1:46b = punish(c,1);%设置惩罚系数%优化计算过程for j = 1:15Z1(1,1) = 175;%下泄流量范围l = length(Qst:1:Qst+25000);Qfd(1:l,j) = (Qst:1:Qst+25000)&#x27;;flg = flg+1;%循环标志位for i = 1:15000if V(1,j) &lt; 171.5    if i-1 == 0        f = 1;    Qfd(i,j) = Qfd(i-1,j);    break;endif f == 1    faulce(1,j) = 1;    break;end%%约束条件编制%发电水头约束[H(i,1) K] = head(Qfd(i,j),Z1(1,j));%输入下泄流量及上游水头%水电站预想出力限制yxcl(i,1) = Yuxcl(H(i,1));%输入当前水头%水电站最大过流能力限制xxnl(i,1) = Xiaxnl(Z1(1,j));%输入当前上游水位%指标函数（含惩罚函数）output(i,j) = K * Qfd(i,j) * H(i,1)/10000;if output(i,j) &gt; yxcl(i,1)    continue;endif output(i,j) &gt;= Pb    Pcl1(i,j) = output(i,j);else    Pcl1(i,j) = output(i,j) + b*(output(i,j)-Pb);end%递推方程Pbest(1,j+1) = max(Pcl1(i,:)+Pbest(1,j));end%建立状态转移方程V(1,j+1) = V(1,j) + (Qrk1(j,1)-Qfd(1,j))*T;%库容曲线约束Z1(1,j+1) = Kurqx(V(1,j+1));%当前时段末水位Z1(1,16) = 145;end%统计发电出力n = size(Pcl1,1);for i = 1:15    for j = 1:n        if Pcl1(j,i) == 0            P1(1,i) = Pcl1(j-1,i);            break;        end        if Pcl1(j,i) &lt;= 0            break;        end        if Pcl1(j,i) &gt;= 0 &amp;&amp; j == n            P1(1,i) = Pcl1(j,i);        end     endend%%优化计算过程2V(1,1) = 171.5;for j = 1:9Z2(1,1) = 164.27;%下泄流量范围l = length(Qst:1:Qst+15000);Qfd(1:l,j) = (Qst:1:Qst+15000)&#x27;;flg = flg+1;%循环标志位for i = 1:15000if V(1,j) &lt; 171.5    Qfd(i,j) = Qfd(i-1,j);    break;end%%约束条件编制%发电水头约束[H(i,1) K] = head(Qfd(i,j),Z2(1,j));%输入下泄流量及上游水头%水电站预想出力限制yxcl(i,1) = Yuxcl(H(i,1));%输入当前水头%水电站最大过流能力限制xxnl(i,1) = Xiaxnl(Z2(1,j));%输入当前上游水位%指标函数（含惩罚函数）output(i,j) = K * Qfd(i,j) * H(i,1)/10000;if output(i,j) &gt; yxcl(i,1)    continue;endif output(i,j) &gt;= Pb    Pcl2(i,j) = output(i,j);else    Pcl2(i,j) = output(i,j) + b*(output(i,j)-Pb);end%递推方程Pbest(i+1,j) = max(Pcl2(i,j)+Pbest(i,j));end%建立状态转移方程V(1,j+1) = V(1,j) + (Qrk2(j,1)-Qfd(1,j))*T;%库容曲线约束Z2(1,j+1) = Kurqx(V(1,j+1));%当前时段末水位Z2(1,16) = 175;end%统计发电出力n = size(Pcl2,1);for i = 1:9    for j = 1:n        if Pcl2(j,i) == 0            P2(1,i) = Pcl2(j-1,i);            break;        end         if Pcl1(j,i) &lt;= 0            break;        end        if Pcl2(j,i) &gt;= 0 &amp;&amp; j == n            P2(1,i) = Pcl2(j,i);        end    endendfor i=1:15    endZ(i,1) = Z1(1,i);endfor i = 16:27    endZ(i,1) = 145;endfor i = 28:36    endZ(i,1) = Z2(1,i-27);endplot(1:36,endZ(1:36,1));xlim([1 36])ylim([145 185])ylabel(&quot;水位/m&quot;);xlabel(&quot;旬&quot;);title(&quot;1975年来流优化调度水位变化曲线&quot;);%&#125;%%计算发电保证率for k = 1:15    P(1,k) = P1(1,k);endfor k = 16:24    P(1,k) = P2(1,k-15);endfor d = 1:24    if P(1,d) &lt; 499       m = m+1;    endendpercent(c,1) = 1-m/24;endend\r\n\r\n基本完成课程设计任务。从最终得到的数据曲线来看，动态规划的问题比较大，另外两种方法均无法达到保证出力，是还没有解决的问题。常规调度第二段若完全按照调度图调度，整体发电甚至会更少。如果仍有时间，可以考虑改变出力目标，尝试全部改为保证出力计算。动态规划需要先做一些简单的小题再理解一下决策变量如何改变。\r\n先这样。over\r\n\r\n","tags":["课设、水电站"]},{"title":"水文预报课设","url":"/2024/06/28/%E6%B0%B4%E6%96%87%E9%A2%84%E6%8A%A5%E8%AF%BE%E8%AE%BE/","content":"任务\r\n本学期第二个课设为水文预报，根据流域选取标准，选择旬河流域作为产汇流计算流域。\r\n设计内容\r\n\r\n洪水场次资料的整理\r\n产流方案设计\r\n汇流方案\r\n精度评价\r\n\r\n最终需要给出预报过程图，包括降雨、实测流量、模拟流量。\r\n设计所需数据\r\n由打包文件.DAT给出，其中退水曲线蓄泄系数取 K1=48h\r\n，流域集水面积6448km²。\r\n洪水场次资料的整理\r\n\r\n暴雨洪水场次的划分：利用预留的1987——1990划分场次洪水资料，根据已给出的洪水场次计算各场洪水的实测洪峰、实测峰现时间和实测洪水总量。\r\n\r\n具体时间如下表： |洪号|流量起止时间| | ----- | --------- | |870513\r\n|05.10-05.20| |870614 |06.11-06.20| |870804 |08.02-08.12| |870903\r\n|09.01-09.09| |880407 |04.01-04.20| |880505 |05.05-05.19| |880705\r\n|07.02-07.16| |880819 |08.17-08.24| |890429 |04.26-05.09| |890711\r\n|07.05-07.22| |890820 |08.14-08.25| |890928 |09.23-10.04| |900501\r\n|04.28-05.13| |900701 |06.29-07.11| |900816 |08.12-08.28|\r\n\r\n为了研究暴雨与洪水之间的关系，必须对流量过程线加以分割（次洪划分），又由于不同水源运动规律不同，要把洪水径流分割为地上径流和地下径流（径流成分划分）。\r\n\r\n计算各场洪水的洪水总量和次洪径流深\r\n由退水指数方程\r\n\\[ Q_t = Q_0e^{\\frac{t}{K}} \\]\r\n计算各次洪水的退水曲线。\r\n以870513为例，利用蓄泄关系法对洪水径流深进行计算，计算公式如下：\r\n\\[ R_0 = 3.6\\Delta\r\nt(\\sum_{i=2}^{n-1}Q_i+\\frac{Q_1+Q_n}{2})/A+R_{e末}-R_{e初} \\]\r\n其中，\\(\\Delta t\\)为24h，\\(R_{e末}-R_{e初}=3.6K(Q_末-Q_初)/A\\)。\r\nIMP：不透水面积比例\r\n计算顺序调整:建立产流计算模型\r\n重新研读任务书后，现将设计顺序改为先建立产流模型，明确计算过程，再梳理需要优化率定的参数。\r\n\r\n首先根据三层蒸发模型计算出该时段的EU、EL、ED，并计算总蒸散发量E。三层蒸发模型具体计算情况分为以下四种：\r\n\r\n\r\n当\\(WU+P \\ge E_P\\)时\r\n\r\n\\[ E_U = E_P , E_L = 0 , E_D = 0\r\n\\]\r\n\r\n当 \\(WU+P &lt; E_P , WL \\ge C \\cdot\r\nWLM\\)时\r\n\r\n\\[ E_U = WU+P , E_L = (E_P-E_U)WL/WLM ,\r\nE_D = 0\\]\r\n\r\n当\\(WU+P&lt;E_P , C(E_P-E_U) \\ge C \\cdot\r\nWLM\\)时\r\n\r\n\\[E_U = WU+P , E_L = C(E_P-E_U) , E_D =\r\n0\\]\r\n\r\n当\\(WU+P&lt;E_P , WL &lt;\r\nC(E_P-E_U)\\)时\r\n\r\n\\[E_U = WU+P , E_L = WL , E_D = C(E_P -\r\nE_U) - E_L\\]\r\n式中，\\(E_P\\)为流域蒸发能力，WL为下层土壤含水量，WLM为下层土壤含水容量，C为蒸发扩散系数，WU为上层土壤含水量，P为降雨量。\r\n\r\n算得蒸散发量之后可以得到净雨量PE，通过PE推求产流量。\r\n\r\n首先需要计算初始土湿分布以计算流域产流比例，确定后续的产流量。\r\n\\[ a =\r\nWMM[1-(1-W/WM)^{\\frac{1}{1+b}}]\\]\r\n在初始土湿为W的条件下，可以建立降雨径流的关系，分为以下两种情况：\r\n\r\n$a + PE WMM $\r\n\r\n\\[R = PE + W - WM + WM(1 -\r\n\\frac{PE+a}{WMM})^{1+b}\\]\r\n\r\n\\(a + PE &gt; WMM\\)\r\n\r\n\\[R = PE - (WM - W)\\]\r\n\r\n根据研究，流域坡地上的降雨产流量因产流过程的条件和运动路径不同，受流域的调蓄作用不同，各径流成分在流量过程线上的反映是不一样的。在实际工作中，因为需要按各种径流成分分别进行计算或模拟，因而要对产流量进行水源划分。\r\n\r\n本次课程设计需要将其划分为地面径流、壤中流和地下径流以备后续计算。\r\n经过分析概化河槽一侧的土壤剖面,可以得出径流特性可用水箱概念模型来描述和分水源。与蓄满产流类似，由于下垫面的不均匀性，自由水蓄量也存在空间分布不均匀性。因此，应考虑产流面积和自由水蓄量空间分布不均匀的影响。2\r\n根据上述理论，可以列出流域平均自由水蓄积容量的关系：\r\n\\[S_m = \\frac{S_{mm}}{1+EX}\\]\r\n设时段初始自由蓄水量为\\(S_1\\),其相应纵坐标为AU，则考虑上时段和本时段产流面积有不同的转换有：\r\n\\[AU = S_{mm}[1-(1-\\frac{S_1 \\cdot\r\nFR_1/FR}{S_m})^{\\frac{1}{1+EX}}]\\]\r\n有了上列计算式，即可划分水源。设扣除雨期蒸发后的降雨量为PE，可分为以下两种情况：\r\n1. \\(PE+AU&lt;S_{mm}\\)\r\n\\[RS = FR[PE+\\frac{S_1 \\cdot FR_1}{FR} -\r\nS_m + S_m(1-\\frac{PE+AU}{S_{mm}})^{1+EX} ]\\]\r\n\r\n\\(PE+AU \\ge S_{mm}\\)\r\n\r\n\\[RS = FR(PE+\\frac{S_1 \\cdot FR_1}{FR} -\r\nS_m)\\]\r\n本时段的自由蓄水量为\r\n\\[S = \\frac{S_1 \\cdot FR_1}{FR} +\r\n\\frac{R-RS}{FR}\\]\r\n相应的壤中流和地下径流为\r\n\\[ RSS = KSS \\cdot S \\cdot FR\\]\r\n\\[ RG = KG \\cdot S \\cdot FR \\]\r\n本时段末即下一时段初的自由水蓄量变为\r\n\\[S_1 = S(1-KSS-KG)\\]\r\n对十五场降水蒸发情况进行迭代计算，得到最终的水源划分结果。\r\n产流计算模型具体代码如下：\r\n\r\n\r\n产流计算模型\r\n\r\n%%产流模型%P时段降雨%ET时段潜在蒸散发%%产流参数WM = 126;WUM = 63;WLM = 13;WDM = 50;KC = 0.71;%流域蒸散发折算系数C = 0.17;B = 2;IMP = 0.001;FE = 0.8;%初始土壤水容量折算系数WMM = WM*(1+B);W(1,:) = WU(1,:)+WL(1,:)+WD(1,:);SM = 36;EX = 0.46;KG = 0.046;KKG = 0.995;KSS = 0.83;KKSS = 0.06;SMM = SM*(1+EX);S1(1,:) = FE*SM;k = 1;WU = zeros(20,k);WL = zeros(20,k);WD = zeros(20,k);R = zeros(20,k);WU(1,:) = FE*WUM;WL(1,:) = FE*WLM;WD(1,:) = FE*WDM;n = 0;for i = 1:20    if E0(i,k) &gt; 0        n = n+1;    endend%%三层蒸发模型for i = 1:n    Ep(i,k) = KC*E0(i,k);    %第一层    if WU(i,k) + P(i,k) &gt;= Ep(i,k)        Eu(i,k) = Ep(i,k);        El(i,k) = 0;        Ed(i,k) = 0;    %第二层    elseif (WU(i,k) + P(i,k) &lt;Ep(i,k)) &amp;&amp; (WL(i,k) &gt;= C*WLM)        Eu(i,k) = WU(i,k) + P(i,k);        El(i,k) = (Ep(i,k)-Eu(i,k))*WL(i,k)/WLM;        Ed(i,k) = 0;    elseif (WU(i,k) + P(i,k) &lt; Ep(i,k)) &amp;&amp; (WL(i,k) &gt; C*(Ep(i,k)-Eu(i,k))) &amp;&amp; (WL(i,k) &lt; C*WLM)        Eu(i,k) = WU(i,k) + P(i,k);        El(i,k) = C*(Ep(i,k) - Eu(i,k));        Ed(i,k) = 0;    %第三层    elseif (WU(i,k) + P(i,k) &lt; Ep(i,k)) &amp;&amp; (WL(i,k) &lt; C*(Ep(i,k)-Eu(i,k)))        Eu(i,k) = WU(i,k) + P(i,k);        El(i,k) = WL(i,k);        Ed(i,k) = C*(Ep(i,k) - Eu(i,k)) - El(i,k);    end    E(i,k) = Eu(i,k)+El(i,k)+Ed(i,k);    PE(i,k) = P(i,k) - E(i,k);        a(i,k) = WMM*(1-(1-W(i,k)/WM)^(1/(1+B)));    %计算i时刻RS，RSS，RG,R    %S为本时段的自由蓄水量    if PE(i,k) &gt; 0%产流        %透水面积产流计算        if a(i,k)+PE(i,k)&lt;=WMM            R(i,k) = PE(i,k)+W(i,k)-WM+WM*(1-(PE(i,k)+a(i,k))/WMM)^(B+1);        else            R(i,k) = PE(i,k)-(WM-W(i,k));        end        %不透水面积产流计算        RIM(i,k) = P(i,k) * IMP;        FR(i,k) = R(i,k)/PE(i,k);        if i == 1            FR1 = 1-(1-W(i,k)/WMM)^B;            AU(i,k) = SMM*(1-(1-S1(i,k)*FR1*FR(i,k)/SM)^(1/(1+EX)));%S1(1,k)为时段初始自由水蓄量        else             AU(i,k) = SMM*(1-(1-S1(i,k)*FR(i,k)*FR(i,k)/SM)^(1/(1+EX)));%S1(1,k)为时段初始自由水蓄量        end        if PE(i,k)+AU(i,k)&lt;SMM            RS(i,k) = FR(i,k)*(PE(i,k)+S1(i,k)-SM+SM*(1-(PE(i,k)+AU(i,k))/SMM)^(EX+1)) + RIM(i,k);            RSS(i,k) = (SM - SM*(1-(PE(i,k)+AU(i,k))/SMM)^(EX+1))*KSS*FR(i,k);            RG(i,k) = (SM - SM*(1-(PE(i,k)+AU(i,k))/SMM)^(EX+1))*KG*FR(i,k);        else            RS(i,k) = FR(i,k)*(PE(i,k)+S1(i,k)*FR(i-1,k)/FR(i,k)-SM) + RIM(i,k);            RSS(i,k) = (PE-SM+S1(i,k))*FR(i,k);            RG(i,k) = SM*KG*FR(i,k);            S1(i,k) = (1-KSS-KG)*SM;        end    else%不产流        R(i,k) = 0;        FR(i,k) = R(i,k)/PE(i,k);        FRt(i,k) = 1 - (1-W(i,k)/WM)^(B/(1+B));        RS(i,k) = 0;%地面径流        RSS(i,k) = S1(i,k)*KSS*FR(i,k);%壤中流        RG = S1(i,k)*KG*FRt(i,k);%地下径流        S1(i+1,k) = (1-KSS-KG)*S1(i,k);    end    %计算土壤含水量的变化    WU(i+1,k)=PE(i,k)+WU(i,k)-R(i,k);    if WU(i+1,k)&gt;=WUM        WL(i+1,k)=WU(i+1,k)-WUM+WL(i,k);        if WL(i+1,k)&gt;=WLM            WD(i+1,k)=WL(i+1,k)-WLM+WD(i,k);            WL(i,k)=WLM;            if WD(i+1,k)&gt;WDM                WD(i+1,k)=WDM;            end        end        WU(i+1,k)=WUM;    end    W(i+1,k)=W(i,k)+PE(i,k)-R(i,k);end%水量平衡检验x1 = sum(E(:,k));x2 = sum(P(:,k));x3 = sum(PE(:,k));x = x3-(x2-x1);if x &lt; 0.001    Y = [&#x27;误差为&#x27;,num2str(x),&#x27;,符合水量平衡&#x27;];    disp(Y);else    disp(&#x27;错误！不符合水量平衡 。&#x27;);end\r\n\r\n进行汇流计算\r\n由于不同水源流速等因素对汇流的影响不同，故需要使用不同的汇流方法计算结果。通常，由地面净雨直接推得的地面径流使用单位线进行计算，地下径流汇流使用线性水库方法计算。\r\n直接应用优选的汇流参数和已给出的单位线对场次暴雨洪水进行单位线计算。壤中流和地下径流用线性水库模型进行求解。计算汇流具体代码如下：\r\n\r\n\r\n汇流计算\r\n\r\n%%单位线汇流计算A = 6448;U = A/(3.6*24);k = k;q = length(RS(:,k));for j = 1:q    for i = 1:n        danweixian(i+j-1,j+2) = danweixian(i,1) * RS(j,k)/10;    endendfor i = 1:n    danweixian(i,j+3) = sum(danweixian(i,3:j+2));endm = length(danweixian(:,j+3));Qend = zeros(m,k);Qg = zeros(m,k);Qss = zeros(m,k);%%线性水库汇流Qg(1,k) = RG(1,k);for i = 1:n    %Qg(1,k) = RO(1,k);    Qg(i+1,k) = RG(i,k)*(1-KKG)*U+Qg(i,k)*KKG;endQss(1,k) = RSS(1,k);for i = 1:n    Qss(i+1,k) = RSS(i,k)*(1-KSS)*U+Qss(i,k)*KSS;endfor p = 1:m    Qend(p,k) = danweixian(p,j+3)+Qg(p,k)+Qss(p,k);end\r\n\r\n按时段进行计算，得出每时段预报结果图\r\n已经完成各个时段预报结果的初步计算，现在存在的问题有，时段8和时段13洪峰量很底且峰现时间出现了错位，需要进一步研究出现该问题的原因。\r\n现将检验所用代码插入如下：\r\n\r\n\r\n预报结果检验\r\n\r\n%%退水曲线检验A = 6448;K = 48;t = 1;k = 8;m = 8;Qtjy(1,k) = Qend(m,k);R = 0;if Qend(1,k) &gt; Qend(2,k) || Qend(1,k) == 0        d = 2;else        d = 1;endwhile Qtjy(t,k) &gt; Qend(d,k)    t = t+1;    Qtjy(t,k) = Qtjy(t-1,k) * exp(-1/K);endl = length(Qtjy(:,k));for i = 1:m    Qtsjy(i,k) = Qend(i,k);endfor i = m:m+t-1    Qtsjy(i,k) = Qtjy(i-m+1,k);end%R(1,k) = sum(Qend(2:m,k))+sum(Qtsjy(m+1:m+t-1,k));R0jy(1,k) = 3.6*24*sum(Qtsjy(1:m+t-1,k))/A;%R0jy(1,k) = 3.6*24*sum(Qend(1:m,k))/A;%R0jy(1,k) = 3.6*24*(R(1,k)+(Qend(1,k)+Qtsjy(l,k))/2)/A + K*3.6*(Qend(m,k)-Qend(d,k))/A;%RO(1,k) = R0jy(1,k) - 3.6*24*(Qts(1,k)+Qts(t-1,k))*(m+t-1-2)/(2*A);%%作图plot(Qend(1:m,k));xlim([1 m+t]);hold on;plot(m:m-1+t,Qtjy(1:t,k));title(&quot;场次一退水曲线&quot;);ylabel(&quot;Q/(m³/s)&quot;);xlabel(&quot;t&quot;);line([d d],[0 Qtsjy(d,k)],&#x27;LineStyle&#x27;,&#x27;--&#x27;);line([m-d+t m-2+t],[0 Qtsjy(m-d+t,k)],&#x27;LineStyle&#x27;,&#x27;--&#x27;);line([2 m-d+t],[Qtsjy(d,k) Qtsjy(m-d+t,k)],&#x27;LineStyle&#x27;,&#x27;--&#x27;);\r\n\r\n在最终绘制对比图代码如下：\r\n\r\n\r\n作图\r\n\r\n%%画图%%绘制实测流量过程、预测流量过程和流域平均降雨量过程示意图k = 8;m = 8;%RS(m,k) = 0;yyaxis left;%激活左边的轴bar(1:m,RS(1:m,k));set(gca,&#x27;YDir&#x27;,&#x27;reverse&#x27;); %反转y轴xlabel(&quot;日期&quot;);ylabel(&quot;left 降雨量(mm)&quot;);ylim([0 50]);yyaxis right;%激活右边的轴plot(1:m,Q(1:m,k));hold onplot(1:m,Qtsjy(1:m,k));%Qtsjyylabel(&quot;right 流量(m³/s)&quot;);xlim([1,m]);ylim([0 3000]);xticks(1:1:m);title(&quot;场次二预报结果&quot;)%&#123;xticklabels([&quot;5-10&quot;,&quot;5-11&quot;,&quot;5-12&quot;,&quot;5-13&quot;,&quot;5-14&quot;,&quot;5-15&quot;,&quot;5-16&quot;,&quot;5-17&quot;,&quot;5-18&quot;,&quot;5-19&quot;,&quot;5-20&quot;]);%&#125;\r\n\r\n\r\n在分析结果后，发现整个预报的参数还有可以率定的余地。在不改变所有计算初值的情况下，现在需要研究各个参数对预报结果的影响，以期改善预报结果。\r\n尝试人工试错优选后，发现参数的改变会出现不好的预报变好了但是好的预报又变差了，所以现在考虑编程，使用Rockenbrock函数法进行参数优选。\r\n[Rockenbrock函数]http://t.csdnimg.cn/3ETMb\r\n\r\n7.4正式完成课设。\r\n总结\r\n本次课设的重点和难点并不在于如何编程和设置数据结构，因为一切使用的公式书中都有给出。重点在于如何通过改变参数使结果能达到一个较好的预期，真正的任务量在于调参，算是一种全新的设计体验。\r\n\r\n\r\n\r\n\r\nK为一确定常数，由\\(W_t=KQ_t\\)确定。该式表明，当泄流流量恒定为\\(Q_t\\)，K是泄完蓄水量\\(W_t\\)所需的时间。由于蓄量分布在流域上，距出口断面的距离远近不同。汇集时间大小不等，其平均汇集时间应等于K。从这个意义上讲，K又可以解释为流域水流平均汇集时间。↩︎\r\n《水文预报（第五版）》，主编：包为民，2017↩︎\r\n\r\n\r\n","tags":["课设"]},{"title":"算法学习记录","url":"/2024/09/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"两数之和\r\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出\r\n和为目标值 target 的那 两个 整数，并返回它们的数组下标。\r\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\r\n你可以按任意顺序返回答案。\r\n思路一、暴力求解\r\n输入所给数组，将其遍历求和，判断其值是否等于目标值，若等于则输出两个数的数组下标。\r\n\r\n\r\n求解代码如下\r\n\r\nclass Solution &#123;public:\tvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\t\tint n = nums.size();\t\tfor(int i = 0; i &lt; n; ++i)&#123;\t\t\tfor(int j = i + 1; j &lt; n; ++j)&#123;\t\t\t\tif(nums[i] + nums[j] == target)&#123;\t\t\t\t\treturn &#123;i , j&#125;;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\treturn &#123;&#125;;\t&#125;&#125;\r\n\r\n\r\n回文数\r\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false\r\n。\r\n回文数 是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\r\n例如，121 是回文，而 123 不是。\r\n思路：反转一半数字\r\n既然数字为回文数，则可以将其反转一半来判断。\r\n首先考虑一些临界情况。一定不是回文数的有负数及个位数，故首先排除。\r\n再来考虑如何反转后半部分的数字。为得到后半数字，可以进行%10计算，在循环内重组后半数字的顺序。例如对于1221这个数字，先通过/10移除最后一个数字得到122，再求出1221%10得到1。122%10则可以得到倒数第二位数字。如果我们把倒数第一位数字*10再加上倒数第二位数字，则得到了反转后的数字，以此类推。\r\n关键在于如何知道我们已经反转了一半的数字。由于我们不断地将原始数字/10，然后给反转的数字*10，故当原始数字小于等于反转后的数字时，我们就已经处理了一半的数字了。\r\n\r\n\r\n回文数\r\n\r\nclass Solution&#123;public:\tbool isPalindrome(int x)&#123;\t\tif(x &lt; 0 || (x/10 == 0 &amp;&amp; x != 0))&#123;\t\treturn false;\t\t&#125;\t\t\t\tint revertedNumber = 0;\t\twhile (x &gt; revertedNumber)&#123;\t\t\trevertedNumber = revertedNumber * 10 + x%10;\t\t\tx /= 10;\t\t&#125;\t\t\t\treturn x == revertedNumber || x == revertedNumber/10\t\t//若x有奇数个数字，则中间一位并不影响回文数的性质，去掉中间一位即可\t&#125;&#125;\r\n\r\n\r\n多数元素\r\n给定一个大小为 n 的数组 nums\r\n，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋\r\n的元素。\r\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\r\n思路：摩尔投票法\r\n核心理念为票数正负抵消。\r\n在本题中，假设数组长度为n，数组的众数为x。\r\n\r\n推论一：若记众数的票数为+1，非众数的票数为-1，则所有数字的和一定&gt;0。\r\n推论二：若数组前a个数票数和为0，则剩余（n-a）个数字的众数仍为x。\r\n\r\n根据以上推论，当发生票数和=0的时候，剩余数组的众数一定不变，因为：\r\n\r\n若 \\(n_1\\) =\r\nx，则已经遍历过的数组中有一半是众数。\r\n若 \\(n_1\\) !=\r\nx，则所有抵消过的数字中众数的个数最小是0个，最大是一半。\r\n\r\n即按照以上推论，每次出现票数和为零都可以缩小搜索范围，直到遍历完成，最后一个假定的数字即为众数。\r\n\r\n\r\n多数元素\r\n\r\nclass Solution &#123;public:    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;        int x = 0, votes = 0;        for (int num : nums)&#123;            if (votes == 0) x = num;//当票数和为零的时候假设当前数字为众数            votes += num == x ? 1 : -1;        &#125;        return x;    &#125;&#125;;\r\n\r\n\r\n区间和的个数\r\n给你一个整数数组 nums 以及两个整数 lower 和 upper\r\n。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的\r\n区间和的个数 。\r\n区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j\r\n(i ≤ j)。\r\n思路：归并排序\r\n设前缀和数组为Prenum ，则等价于对所有下标\r\n(i,j)，满足 \\[Prenum[j]-Prenum[i]\\in(lower,upper)\\]\r\n我们先考虑两个升序排列的数组\\(n_1\\),\\(n_2\\),试找出所有下标对\r\n(i,j),满足\r\n\\[n_1[j]-n_2[i]\\in(lower,upper)\\]\r\n在已知两个数组为升序排列的情况下，是相对简单的。我们维护两个指针l,r。起初，他们都指向\\(n_2\\)的起点。\r\n随后，我们首先考察\\(n_1\\)的第一个元素。首先，不断将指针l向右移动，直到\\(n_2[l]-n_1[0]\\ge\r\nlower\\)为止，则此时l右侧的所有元素都满足\\(n_2[i]-n_1[0]\\ge\r\nlower\\)；然后，向右移动r，直到\\(n_2[r]-n_1[0]\\ge\r\nupper\\)为止，此时r左侧的所有元素都满足\\(n_2[r]-n_1[0]\\leq\r\nupper\\)。故l,r区间内的所有元素都满足\r\n\\[n_1[j]-n_2[i]\\in(lower,upper)\\]\r\n至此，由于数组是升序排列的，所以l,r都只需要向右移动，依此来遍历\\(n_1\\)中的所有元素，每次都统计下标\r\n(l,r) 的大小，我们就得到了区间和的数量。\r\n因此最后需要考虑的就是得到两个升序数组，则使用归并排序对原数组处理得到两个升序数组用于计算。\r\n\r\n\r\n区间和的个数\r\n\r\nclass Solution &#123;public:    int countRangeSumRecursive(vector&lt;long&gt;&amp; sum, int lower, int upper, int left, int right) &#123;        if (left == right) &#123;            return 0;        &#125; else &#123;            int mid = (left + right) / 2;            int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);            int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);            int ret = n1 + n2;            // 首先统计下标对的数量            int i = left;            int l = mid + 1;            int r = mid + 1;            while (i &lt;= mid) &#123;                while (l &lt;= right &amp;&amp; sum[l] - sum[i] &lt; lower) l++;                while (r &lt;= right &amp;&amp; sum[r] - sum[i] &lt;= upper) r++;                ret += (r - l);                i++;            &#125;            // 随后合并两个排序数组            vector&lt;long&gt; sorted(right - left + 1);            int p1 = left, p2 = mid + 1;            int p = 0;            while (p1 &lt;= mid || p2 &lt;= right) &#123;                if (p1 &gt; mid) &#123;                    sorted[p++] = sum[p2++];                &#125; else if (p2 &gt; right) &#123;                    sorted[p++] = sum[p1++];                &#125; else &#123;                    if (sum[p1] &lt; sum[p2]) &#123;                        sorted[p++] = sum[p1++];                    &#125; else &#123;                        sorted[p++] = sum[p2++];                    &#125;                &#125;            &#125;            for (int i = 0; i &lt; sorted.size(); i++) &#123;                sum[left + i] = sorted[i];            &#125;            return ret;        &#125;    &#125;    int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;        long s = 0;        vector&lt;long&gt; sum&#123;0&#125;;        for(auto&amp; v: nums) &#123;            s += v;            sum.push_back(s);        &#125;        return countRangeSumRecursive(sum, lower, upper, 0, sum.size() - 1);    &#125;&#125;;\r\n\r\n\r\n最大装水\r\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i\r\n条线的两个端点是 (i, 0) 和 (i, height[i]) 。\r\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\r\n返回容器可以储存的最大水量。\r\n说明：你不能倾斜容器。\r\n思路：双指针\r\n水箱的面积大小由左右两侧最短板的长度决定，故可以得到以下计算公式：\r\n\\[S = min(height[i],height[j]) \\times (j\r\n-i)\\]\r\n设置两个指针分别指向水箱的两个端点，当指针对撞的时候结束计算。\r\n每一次移动指针向内收窄，都会导致底板长度-1，这时面积的变化会有两种可能：\r\n1、将指向较长板的指针向内收窄：由于底的长度一定会减小，而板的最小值的长度一定会减小或者不变，故得到的面积\\(S\\leq S_{min}\\)\r\n2、将指向较短板的指针向内收窄：由于板的最小值只可能变大（下一个最短板的长度大于当前最短板）或不变（即当前最短板的长度等于下一组最短板的长度）。\r\n由此，得到解题算法：比较前后指针所指向的板长，每次将指向较短板的指针向内移动，保存最大面积值，直到指针相撞比较结束，返回最大面积。\r\n\r\n\r\n最大装水\r\n\r\nclass Solution &#123;public:    int maxArea(vector&lt;int&gt;&amp; height) &#123;        int i = 0, j = height.size() - 1, res = 0;        while(i &lt; j) &#123;            res = height[i] &lt; height[j] ?                 max(res, (j - i) * height[i++]):                 max(res, (j - i) * height[j--]);         &#125;        return res;    &#125;&#125;;\r\n\r\n数组中的第k大的元素\r\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\r\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k\r\n个不同的元素。\r\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\r\n思路：快速选择\r\n设N为数组长度，根据快速排序原理，如果某次哨兵划分后，基准数的索引恰好为\\(N-k\\),则意味着它就是第k大的数字，可以直接返回。\r\n对于包含大量重复数字的数组，每轮的哨兵划分都有可能划分为长度为1，和n-1两个部分，时间复杂度会退化至\\(O(n^2)\\)。\r\n有一种解决办法是使用三路划分，即每次都把数组划分为大于、小于、等于基准数的三部分。\r\n\r\n\r\n数组中第k大的元素\r\n\r\nclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        return quickSelect(nums, k);    &#125;    private:    int quickSelect(vector&lt;int&gt;&amp; nums, int k) &#123;        // 随机选择基准数        int pivot = nums[rand() % nums.size()];        // 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中        vector&lt;int&gt; big, equal, small;        for (int num : nums) &#123;            if (num &gt; pivot)                big.push_back(num);            else if (num &lt; pivot)                small.push_back(num);            else                equal.push_back(num);        &#125;        // 第 k 大元素在 big 中，递归划分        if (k &lt;= big.size())            return quickSelect(big, k);        // 第 k 大元素在 small 中，递归划分        if (nums.size() - small.size() &lt; k)            return quickSelect(small, k - nums.size() + small.size());        // 第 k 大元素在 equal 中，直接返回 pivot        return pivot;    &#125;&#125;;\r\n\r\n\r\n股票\r\n有一支股票，你只有一股，已知过去N天的股价，只能进行一次买卖，请问你能获得最大利润是多少\r\n（给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第\r\ni 天的价格。\r\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子\r\n卖出该股票。设计一个算法来计算你所能获取的最大利润。\r\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0\r\n。）\r\n思路：找到已经过去的每一天的最小值\r\n在买卖股票的时候，为了获得最高的利润，肯定希望在最低价买入，在最高价卖出。由此，我们可以遍历数组一边，每次记录已遍历的部分的最小值，然后用于计算和数组后面数字的差的最大值。\r\n\r\n\r\n买卖股票的时机\r\n\r\nclass Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int inf = 1e9;        int minprice = inf, maxprofit = 0;        for (int price: prices) &#123;            maxprofit = max(maxprofit, price - minprice);            minprice = min(price, minprice);        &#125;        return maxprofit;    &#125;&#125;;\r\n\r\n\r\n判断一个链表中是否存在一个环\r\n给出一个链表A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;D，如何判断是否存在环。\r\n思路：快慢指针\r\n有序三元数组的最大值\r\n给你一个下标从 0 开始的整数数组 nums 。\r\n请你从所有满足 i &lt; j &lt; k 的下标三元组 (i, j, k)\r\n中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回\r\n0 。\r\n下标三元组 (i, j, k) 的值等于 (nums[i] - nums[j]) * nums[k] 。\r\n思路：类似股票问题\r\n和上述买卖股票问题相似，可以先存储（nums[i] -\r\nnums[j]）的最大值，然后枚举k得到三元数组的最大值。\r\n\r\n\r\n有序三元数组的最大值\r\n\r\nclass Solution &#123;public:    long long maximumTripletValue(vector&lt;int&gt; &amp;nums) &#123;        long long ans = 0;        int max_diff = 0, pre_max = 0;        for (int x : nums) &#123;            ans = max(ans, (long long) max_diff * x);            max_diff = max(max_diff, pre_max - x);            pre_max = max(pre_max, x);        &#125;        return ans;    &#125;&#125;;\r\n\r\n\r\n滑动窗口的最大值\r\n给你一个整数数组 nums，有一个大小为 k\r\n的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k\r\n个数字。滑动窗口每次只向右移动一位。\r\n返回 滑动窗口中的最大值 。\r\n思路：单调队列\r\n通过移动窗口，可以看到每移动一次，队尾向右增加一个数字，队首减少一个数字。每次出队的元素都有可能是最大值，即小于新入队的元素。故想到每次出队入队都将原窗口内的数字和即将入队的数字比较，将最大值存入窗口，将小于最大值的所有元素移出窗口，保证窗口中的第一个元素为当前窗口内的最大值，则整个判断过程只需要遍历一次，时间复杂度为O(1)。\r\n\r\n\r\n单调队列\r\n\r\nclass Solution &#123;public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        if(nums.size() == 0 || k == 0) return &#123;&#125;;        deque&lt;int&gt; deque;        vector&lt;int&gt; res(nums.size() - k + 1);        for(int j = 0, i = 1 - k; j &lt; nums.size(); i++, j++) &#123;            // 删除 deque 中对应的 nums[i-1]            if(i &gt; 0 &amp;&amp; deque.front() == nums[i - 1])                deque.pop_front();            // 保持 deque 递减            while(!deque.empty() &amp;&amp; deque.back() &lt; nums[j])                deque.pop_back();            deque.push_back(nums[j]);            // 记录窗口最大值            if(i &gt;= 0)                res[i] = deque.front();        &#125;        return res;    &#125;    &#125;&#125;;\r\n\r\n\r\n存在重复元素\r\n给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个\r\n不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k\r\n。如果存在，返回 true ；否则，返回 false 。\r\n思路：滑动窗口\r\n由于只需要判断在k范围内是否存在重复元素，故可以使用滑动窗口限制比较的元素的数量。\r\n\r\n\r\n滑动窗口\r\n\r\nclass Solution &#123;public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_set&lt;int&gt; s;        int length = nums.size();        for (int i = 0; i &lt; length; i++) &#123;            if (i &gt; k) &#123;                s.erase(nums[i - k - 1]);            &#125;            if (s.count(nums[i])) &#123;//计算出现的次数                return true;            &#125;            s.emplace(nums[i]);//将元素添加到队列末尾        &#125;        return false;    &#125;&#125;;\r\n\r\n\r\n序列化分\r\n给定一个正整数序列，将该序列化分为m个连续的子序列，每个子序列至少包含一个元素，要求使得子序列的和的最大值最小。\r\n思路：二分查找\r\n对于整数数列，他的子序列和的最大值的范围为：最小值：序列中单个元素的最大值(即将单个元素划分为子列)；最大值：序列中所有元素的和(即将整个序列划分为子列)，故二分查找的区间为[min,max]。\r\n二分查找是为了更快的实现在子序列的个数已经限定的条件下，找到子序列和的最大值最小的情况。\r\n具体算法：\r\n1、先选取查找区间中点元素作为最大值，判断在该最大值的情况下，序列是否可以划分为要求的m个子序列。若划分个数\r\nn&lt;m ，则说明最大值过大，若 n&gt;m\r\n，则说明最大值取得过小，依此找到题目要求的最大值的最小值。\r\n\r\n\r\n二分查找\r\n\r\nint n, m;int a[maxn];int check(int x) &#123;\tint cut = 1;\tint s = a[1];\tfor (int i = 2; i &lt;= n; i++) &#123;\t\tif (s + a[i] &lt;= x) s += a[i];\t\telse &#123; s = a[i]; cut++; &#125;\t&#125;\treturn cut;&#125;int bin_search(int l, int r) &#123;\twhile (l &lt; r) &#123;\t\tint mid = l + (r - l) / 2;\t\tif (check(mid) &lt;= m) &#123;\t\t\tr = mid;\t\t&#125;\t\telse &#123;\t\t\tl = mid + 1;\t\t&#125;\t&#125;\treturn l;&#125;int main() &#123;\tint t;\tll mx, sum;\tcin &gt;&gt; t;\twhile (t--) &#123;\t\tmx = 0, sum = 0;\t\tcin &gt;&gt; n &gt;&gt; m;\t\tfor (int i = 1; i &lt;= n; i++) &#123;\t\t\tcin &gt;&gt; a[i];\t\t\tsum += a[i];\t\t\tif (mx &lt; a[i])\t\t\t\tmx = a[i];\t\t&#125;\t\tint ans = bin_search(mx, sum);\t\tcout &lt;&lt; ans;\t&#125;\treturn 0;&#125;\r\n\r\n\r\n分裂数组（一）\r\n给定一个整数集合,将其划分为两个不相交的子集A1和A2,元素个数分别是n1和n2,元素之和分别是S1和S2.设计一个算法满足|n1-n2|最小且|S1-S2|最小.\r\n思路：动态规划\r\n要将一个整数集合划分为两个不相交的子集，使得两个子集的元素个数之差\r\n∣n1−n2∣ 和元素之和之差 ∣S1−S2∣\r\n都尽可能小，我们可以利用动态规划的方法来解决这个问题。\r\n具体来说，我们可以使用一个二维动态规划数组 dp[i][j]\r\n来表示：当前集合的前 i\r\n个元素能否被划分为两个子集，使得其中一个子集的和为\r\nj。然后，我们可以进一步记录划分方案，以找到最佳的划分方式。\r\n以下是算法的具体步骤：\r\n初始化动态规划数组：\r\ndp[i][j] 表示前 i 个元素能否划分出和为 j 的子集。\r\n初始化 dp[0][0] = True，表示空集合可以划分出和为 0 的子集。\r\n填充动态规划数组：\r\n遍历集合中的每个元素 num 和每个可能的和 j。\r\n如果 dp[i-1][j] 为 True，那么 dp[i][j+num] 也为 True，表示可以将 num\r\n加入到和为 j 的子集中。 记录划分方案：\r\n使用一个额外的数组来记录每个 j 对应的划分方案中是否包含当前元素 num。\r\n寻找最佳划分：\r\n遍历所有可能的和 j，找到最接近集合总和一半的和，从而确保 ∣S1−S2∣\r\n最小。 在找到的和附近，寻找元素个数之差 ∣n1−n2∣ 最小的划分。\r\n\r\n\r\n动态规划\r\n\r\ndef min_difference_partition(nums):      total_sum = sum(nums)      n = len(nums)      half_total = total_sum // 2            # Initialize dp array      dp = [[False] * (half_total + 1) for _ in range(n + 1)]      dp[0][0] = True            # Include/Exclude array to keep track of partition      include = [[False] * (half_total + 1) for _ in range(n + 1)]            # Fill dp array      for i in range(1, n + 1):          for j in range(half_total + 1):              if j &gt;= nums[i-1]:                  dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]                  include[i][j] = include[i-1][j] if dp[i-1][j] else include[i-1][j-nums[i-1]]              else:                  dp[i][j] = dp[i-1][j]                  include[i][j] = include[i-1][j]            # Find the maximum sum that can be achieved up to half_total      max_sum = 0      for j in range(half_total, -1, -1):          if dp[n][j]:              max_sum = j              break            # Trace back to find the partition      partition1 = []      partition2 = nums[:]      current_sum = max_sum            for i in range(n, 0, -1):          if include[i][current_sum]:              partition1.append(nums[i-1])              current_sum -= nums[i-1]          else:              partition2.remove(nums[i-1])            # Calculate results      n1, n2 = len(partition1), len(partition2)      S1, S2 = sum(partition1), sum(partition2)            # Optionally, further adjust to balance n1 and n2 if needed      # This is an NP-hard problem in general, but here we can do some greedy adjustments      # if possible to minimize |n1 - n2| while keeping |S1 - S2| small.            # However, since we already balanced S1 and S2 optimally, we focus on the best we found.            return partition1, partition2, n1, n2, S1, S2    \r\n\r\n\r\nN皇后问题\r\n按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\r\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n\r\n的棋盘上，并且使皇后彼此之间不能相互攻击。\r\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\r\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和\r\n'.' 分别代表了皇后和空位。\r\n思路：排列型回溯\r\n\r\n\r\nN皇后问题\r\n\r\nclass Solution:    def solveNQueens(self, n: int) -&gt; List[List[str]]:        ans = []        queens = [0] * n  # 皇后放在 (r,queens[r])        col = [False] * n        diag1 = [False] * (n * 2 - 1)        diag2 = [False] * (n * 2 - 1)        def dfs(r: int) -&gt; None:            if r == n:                ans.append([&#x27;.&#x27; * c + &#x27;Q&#x27; + &#x27;.&#x27; * (n - 1 - c) for c in queens])                return            # 在 (r,c) 放皇后            for c, ok in enumerate(col):                if not ok and not diag1[r + c] and not diag2[r - c]:  # 判断能否放皇后                    queens[r] = c  # 直接覆盖，无需恢复现场                    col[c] = diag1[r + c] = diag2[r - c] = True  # 皇后占用了 c 列和两条斜线                    dfs(r + 1)                    col[c] = diag1[r + c] = diag2[r - c] = False  # 恢复现场        dfs(0)        return ans\r\n单词接龙\r\n字典 wordList 中从单词 beginWord 到 endWord 的 转换序列\r\n是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt;\r\nsk： 每一对相邻的单词只差一个字母。 对于 1 &lt;= i &lt;= k 时，每个 si\r\n都在 wordList 中。注意， beginWord 不需要在 wordList 中。 sk == endWord\r\n给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从\r\nbeginWord 到 endWord 的 最短转换序列 中的 单词数目\r\n。如果不存在这样的转换序列，返回 0 。\r\n思路：广度优先搜索\r\n本题要求的是最短转换序列，首先想到的就是广度优先搜索。广度优先搜索自然而然就可以想到图，但题中并没有给出图，所有首先构造一个图。我们把每一个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。\r\n基于该图，我们以beginWord为图的起点，以endWord为终点进行广度优先搜索，寻找beginWord到endWord的最短路径。\r\n由于根据给定的字典构造的图可能会很大，而加入每个结点的分支数量相同，搜索空间会随着层数的增长指数级的增加。则考虑使用两个同时进行的广度搜索，这样可以减少搜索空间。一边从beginWord开始，一边从endWord开始，当发现某一时刻两边都访问过同一顶点时就停止搜索。\r\n算法\r\n首先为了方便表示，我们先给每一个单词标号，即给每一个单词分配一个id，创建一个由单词word到id对应的映射wordId,并将beginWord与wordList中所有的单词都加入这个映射中，之后检查endWord是否在该映射内，若不存在则输入无解。\r\n\r\n\r\n单词接龙\r\n\r\nclass Solution &#123;public:    unordered_map&lt;string, int&gt; wordId;    vector&lt;vector&lt;int&gt;&gt; edge;    int nodeNum = 0;    void addWord(string&amp; word) &#123;        if (!wordId.count(word)) &#123;            wordId[word] = nodeNum++;            edge.emplace_back();        &#125;    &#125;    void addEdge(string&amp; word) &#123;        addWord(word);        int id1 = wordId[word];        for (char&amp; it : word) &#123;            char tmp = it;            it = &#x27;*&#x27;;            addWord(word);            int id2 = wordId[word];            edge[id1].push_back(id2);            edge[id2].push_back(id1);            it = tmp;        &#125;    &#125;    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;        for (string&amp; word : wordList) &#123;            addEdge(word);        &#125;        addEdge(beginWord);        if (!wordId.count(endWord)) &#123;            return 0;        &#125;        vector&lt;int&gt; dis(nodeNum, INT_MAX);        int beginId = wordId[beginWord], endId = wordId[endWord];        dis[beginId] = 0;        queue&lt;int&gt; que;        que.push(beginId);        while (!que.empty()) &#123;            int x = que.front();            que.pop();            if (x == endId) &#123;                return dis[endId] / 2 + 1;            &#125;            for (int&amp; it : edge[x]) &#123;                if (dis[it] == INT_MAX) &#123;                    dis[it] = dis[x] + 1;                    que.push(it);                &#125;            &#125;        &#125;        return 0;    &#125;&#125;;\r\n\r\n平面最近点对\r\nhttps://oi-wiki.org/geometry/nearest-points/\r\n用最少数量的箭引爆气球\r\n有一些球形气球贴在一堵用 XY\r\n平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] =\r\n[xstart, xend] 表示水平直径在 xstart 和\r\nxend之间的气球。你不知道气球的确切 y 坐标。\r\n一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x\r\n处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足\r\nxstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。\r\n弓箭一旦被射出之后，可以无限地前进。\r\n给你一个数组 points ，返回引爆所有气球所必须射出的 最小弓箭数 。\r\n思路：贪心算法\r\n解释题意，就是把这些区间画在数轴上，在数轴上最少要放置多少个点使得每个区间都包含至少一个点。\r\n把区间按照右端点从小到大排序，这样第一个点就放在第一个区间的右端点处。去掉包含第一个点的区间后，第二个点就放在剩余区间的第一个区间的右端点处，以此类推。\r\n\r\n\r\n引爆气球\r\n\r\nclass Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points.sort(key=lambda p: p[1])  # 按照右端点从小到大排序        ans = 0        pre = -inf        for start, end in points:            if start &gt; pre:  # 上一个点在区间左边                ans += 1                pre = end  # 在区间的最右边放一个点        return ans\r\n\r\n柠檬水找零\r\n在柠檬水摊上，每一杯柠檬水的售价为 5\r\n美元。顾客排队购买你的产品，（按账单 bills\r\n支付的顺序）一次购买一杯。\r\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20\r\n美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5\r\n美元。\r\n注意，一开始你手头没有任何零钱。\r\n给你一个整数数组 bills ，其中 bills[i] 是第 i\r\n位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false\r\n。\r\n思路：分类讨论\r\n\r\n\r\n柠檬水找零\r\n\r\nclass Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        five = ten = 0        for b in bills:            if b == 5:  # 无需找零                five += 1            elif b == 10:  # 返还 5                five -= 1                ten += 1            elif ten:  # 此时 b=20，返还 10+5                five -= 1                ten -= 1            else:  # 此时 b=20，返还 5+5+5                five -= 3            if five &lt; 0:  # 无法正确找零                return False        return True\r\n\r\n","tags":["算法学习"]},{"title":"流域水文模型结课作业","url":"/2024/10/09/%E6%B5%81%E5%9F%9F%E6%B0%B4%E6%96%87%E6%A8%A1%E5%9E%8B%E7%BB%93%E8%AF%BE%E4%BD%9C%E4%B8%9A/","content":"任务\r\n采用流域水文模型进行流域降雨-径流模拟。本次模拟中采用线性扰动LPM模型。\r\n模型概况 1\r\n总径流响应（SLM）模型的系统方程\r\n离散化的系统方程表达为：\\[Y(k) =\r\n\\sum_{i=1}^{m}H(i)X(k-i+1) \\tag{0.1}\\]\r\n水文预报的应用之一就是由降雨X(k)推求总径流Y(k)。显然，其中的前提就是已知系统的响应函数H(i)。然而，在未完全建立SLM模型之前，响应函数是有待确定的。我们把由历史上（或实时方式）观测的输入、输出信息[X(k)、Y(K)]用来便是水文系统模型中未知或待定的部分，称之为水文系统识别。它是水文系统方法中重要的内容之一。只有把系统模型中待定的部分都确定了，才能应用到实际的水文预报或水温计算。对于总径流线性响应模型，系统识别的问题归为水文模型响应函数的推求。采用最多的是矩阵最小二乘法，简述如下：\r\n考虑到所用资料有误差，或对系统所作的线性假定不完善，式(0.1)可做如下表述：\\[Y(k)=\\sum_{i=1}^{m}X(k-i+1)H(i)+e(k)\r\n\\tag{0.2}\\] 式中,e(k)为随机误差项。\r\n随着水文时间序列的变化，即当k=1,2,...,n时，式（0.2）可逐行写为： \\[Y(1) = X(1)H(1)+e(1)\\] \\[Y(2) = X(1)H(2) + X(2)H(1) + e(2)\\] \\[\\vdots\\] \\[Y(m)\r\n= X(1)H(m) + X(2)H(m-1) + \\dots + X(m)H(1) + e(m)\\] \\[\\vdots\\] \\[Y(n)\r\n= X(n-m+1)H(m) + X(n-m+2)H(m-1) + \\dots +X(n)H(1) + e(n)\\]\r\n他们可以用矩阵方程形式表达，简记为\\[Y_{n\\times 1} = X_{n\\times n}H_{m\\times 1} +\r\nE_{n\\times 1} \\tag{0.2}\\]\r\n式中，n代表水文资料的总长度，m是响应函数的记忆长度。由于n&gt;m，式（0.2）是一个超定方程组，其中的响应函数向量\\(H_{m\\times 1} =\r\n[h(1),h(2),\\dots,h(m)]^L\\)可采用最小二乘法识别。目标函数记为\\[J(H)=\\sum_{k=1}^{n}e^2(k)=E^TE=(Y-XH)^T(Y-XH)\r\n\\\\=Y^TY-2H^TX^TY+H^TX^TXH \\tag{0.3}\\]\r\n由目标函数极小化，即min{J(H)}，不难导出响应函数的最小二乘解向量为：\\[\\hat H = [X^TX]^{-1}[X^TY] \\tag{0.4}\\]\r\n线性扰动模型的结构和基本假定\r\n线性扰动模型建立的思想是：依据观测的降雨径流（或河道输入输出）资料记为{I(k),Q(k)}，计算季节均值及其平滑值，分别记为\\(I_d\\)和\\(Q_d\\)。关于\\(I_d\\)~\\(Q_d\\)之间的复杂关系不作任何假定。然后，分别计算系统输入、输出变量相对他们季节均值的扰动项，即\\[X(k) = I(k) - I_d \\tag{1}\\] \\[Y(k) = Q(k) - Q_d \\tag{2}\\]\r\n由于一个水文输入~输出序列中季节均值占有主导部分，为简化模型假定：输入的扰动项\\(X(k) = I(k) - I_d\\)与输出的扰动项\\(Y(k) = Q(k) -\r\nQ_d\\)之间存在线性关系，即\\[Y(k) =\r\n\\sum_{j=1}^{m}H(j)X(k-j+1)+e(k) \\tag{3}\\]\r\n式中，H(j)被称为线性扰动系统响应函数，e(k)为误差，则我们把由上述三式组合的系统模型称为线性扰动模型（LPM）。\r\n模型建立具体步骤2\r\n\r\n由观测的资料分别计算水文系统输入~输出序列样本的季节均值\\(I_d\\)和\\(Q_d\\)，d=1,2,3...,365。\r\n季节均值是流域的基本水文属性之一，应当是比较平稳的过程。但实际中求得的季节均值不可避免地带有随机噪音而出现振荡，因此，需要采用一定的数学方法使季节均值光滑。本次计算使用傅里叶级数法进行光滑。数学方程为：\r\n\\[Q_d = \\bar{Q_d} +\r\n\\sum_{j=1}^{L}[A_jcos(\\frac{2\\pi jd}{365}) + B_jsin(\\frac{2\\pi\r\njd}{365})] \\tag{4}\\] 式中，\\(\\bar{Q_d}\\)为均值，\\(A_j\\)和\\(B_j\\)为傅里叶系数，j为调和函数的序数，即\r\n\\[\\bar{Q_d} =\r\n\\frac{1}{365}\\sum_{j=1}^{365}Q_d \\tag{5}\\] \\[A_j =\r\n\\frac{2}{365}\\sum_{d=1}^{365}Q_dcos(\\frac{2\\pi jd}{365})\r\n\\tag{6}\\] \\[B_j =\r\n\\frac{2}{365}\\sum_{d=1}^{365}Q_dsin(\\frac{2\\pi jd}{365})\r\n\\tag{7}\\]\r\n\r\n当式(4)中的调和函数只取得几项时，就得到\\(Q_d\\)的光滑过程。实际中，一般取L=4或5个调和系数。\r\n\r\n利用式（1）、（2）计算输入扰动项X(k)和输出扰动项Y(k)形成式（3）的线性系统方程。\r\n采用与线性总径流模型相同的方法，由最小二乘法识别LPM模型的相应函数\\(\\hat H(j)\\)。\r\n一旦响应函数已经求得，便可利用式（3）由降雨（或上流入流）的扰动值X(k)求得相应的出流扰动\\(\\hat Y(k)\\)。\r\n由此计算或预报出系列\\(Q(k)=Q_d+\\hat\r\nY(k)\\)。\r\n\r\n模型建立\r\n计算平滑后数据\r\n此次模型建立取L=4进行平滑。根据上述公式对Q、P、E得到平滑结果如下：\r\n  \r\n建立线性系统方程\r\n根据式（1）（2）计算输入输出扰动项并得到类似式（3）的线性系统方程。\r\n使用遗传算法计算\\(\\hat H(k)\\)\r\n首先编写一个简单的遗传算法代码：\r\n\r\n\r\n初始化种群:该函数生成一个大小为pop_size的初始种群，每个个体的基因长度为gene_length，基因值为0或1。\r\n\r\nfunction population = initialize_population(pop_size, gene_length)    population = randi([0, 1], pop_size, gene_length);end\r\n\r\n\r\n\r\n适应度函数：该函数计算个体的适应度，适应度为个体中1的数量。\r\n\r\nfunction fit = fitness(individual)    fit = sum(individual);  % Example: maximize the number of 1send\r\n\r\n\r\n\r\n选择操作：这个函数根据适应度选择个体，适应度越高，被选中的概率越大。randsample函数用于带权重的随机抽样\r\n\r\nfunction selected_population = selection(population, fitnesses)    total_fitness = sum(fitnesses);    probabilities = fitnesses / total_fitness;    selected_indices = randsample(1:length(population), length(population), true, probabilities);    selected_population = population(selected_indices, :);end\r\n\r\n\r\n\r\n交叉操作：这个函数对两个父代个体进行交叉操作，生成两个子代个体。交叉点是随机选择的\r\n\r\nfunction [offspring1, offspring2] = crossover(parent1, parent2)    point = randi([1, length(parent1) - 1]);    offspring1 = [parent1(1:point), parent2(point+1:end)];    offspring2 = [parent2(1:point), parent1(point+1:end)];end\r\n\r\n\r\n\r\n变异操作：该函数对个体进行变异操作，每个基因以mutation_rate的概率发生变异，xor用于反转基因值\r\n\r\nfunction mutated_individual = mutate(individual, mutation_rate)    mutation_mask = rand(size(individual)) &lt; mutation_rate;    mutated_individual = xor(individual, mutation_mask);end\r\n\r\n\r\n\r\n生成新一代：这个函数生成新一代种群，通过选择、交叉和变异操作生成新的个体\r\n\r\nfunction new_pop = new_generation(population, mutation_rate)    new_pop = zeros(size(population));    for i = 1:2:length(population)        parent1 = population(i, :);        parent2 = population(i+1, :);        [offspring1, offspring2] = crossover(parent1, parent2);        new_pop(i, :) = mutate(offspring1, mutation_rate);        new_pop(i+1, :) = mutate(offspring2, mutation_rate);    endend\r\n\r\n\r\n\r\n遗传算法主函数：该函数包含遗传算法的核心部分，包括上述所有函数以及终止条件，并最终输出结果\r\n\r\nfunction final_population = genetic_algorithm(pop_size, gene_length, mutation_rate, generations)    population = initialize_population(pop_size, gene_length);    for gen = 1:generations        fitnesses = arrayfun(@fitness, population);        if max(fitnesses) == gene_length            break;  % Terminate if an optimal solution is found        end        population = selection(population, fitnesses);        population = new_generation(population, mutation_rate);        fprintf(&#x27;Generation %d: Max Fitness = %d\\n&#x27;, gen, max(fitnesses));    end    final_population = population;end\r\n\r\nfitnesses = arrayfun(@fitiness,population)语法\r\n\r\narrayfun:arrayfun函数在matlab中用于对数组的每个元素应用指定的函数，它的语法是\r\narrayfun(function_handle,array)\r\n其中function_handle是要应用的函数，array是要处理的数组。\r\n@fitness：@fitness是一个函数句柄，指向定义的fitness函数。在上文已经提及其用于计算个体的适应度。\r\npopulation：population是一个矩阵，表示当前种群。每一行代表一个个体，每一列代表一个基因。\r\n\r\n\r\n\r\n\r\n\r\n参数设置和运行：这部分代码设置了包括种群大小、基因长度、变异率和最大代数等参数，并运行遗传算法\r\n\r\n% Parameterspop_size = 10;gene_length = 8;mutation_rate = 0.01;generations = 100;% Run Genetic Algorithmfinal_population = genetic_algorithm(pop_size, gene_length, mutation_rate, generations);disp(&#x27;Final Population:&#x27;);disp(final_population);\r\n\r\n然后对其进行改写。\r\n首先，对进行交叉、进行变异、生成下一代的函数不做任何改变，用来进行交叉操作，变异操作，生成下一代。\r\n对于适应度函数，由于本次课设任务为拟合流量过程，因此将个体适应度改为在线性系统方程中所得到的函数值与流量数据的差值。\r\nfunction fit = fitness(individual)    fit = abs(Y(i)-bin2dec(individual)*X(i));  %将个体由二进制转化为十进制进行计算end\r\n选择操作中，根据适应度选择个体。在上述情况下，设置适应度最小的个体最有可能被选中。\r\nfunction selected_population = selection(population, fitnesses)    total_fitness = sum(fitnesses);    probabilities = 1 - fitnesses / total_fitness;    selected_indices = randsample(1:length(population), length(population), true, probabilities);    selected_population = population(selected_indices, :);end\r\n对于参数的随机生成，由于选取的参数为方程的系数，且样本数据较大会导致循环次数较多，因此需要限制生成的参数为小数且小数和整数部分的长度都不过长。\r\n%parameterspop_size = 100;gene_length = 8;mutation_rate = 0.01;generations = 100;\r\n还需要编制按照上述要求将生成的二进制样本转化为十进制数的函数bin_dec。\r\nfunction decimal = bin_dec(population)    int_part(j,1:5) = population(j,1:5);    frac_part(j,1:3) = population(j,6:8);    a = length(int_part(j,:));    b = length(frac_part(j,:));    % Convert the integer part    decimal_int(1,j) = 0;    for i = 1:a        decimal_int(1,j) = decimal_int(1,j) + int_part(j,i) * 2^(a - i);    end    % Convert the fractional part    decimal_frac(1,j)  = 0;    for i = 1:b        decimal_frac(1,j) = decimal_frac(1,j)  + frac_part(j,i) * 2^(-i);    end    % Combine the integer and fractional parts    decimal(j) = decimal_int(j) + decimal_frac(j);end\r\n最后还需要修改程序的数据结构，对X(k),Y(k)中三年内的数据进行计算，得到每一日输入输出的响应函数，最终得到结果。\r\n需要注意的是，由于整个代码都使用函数进行计算，而函数工作区和普通工作区是不互通的，因此需要进行参数的传递。主要需要解决的是由arrayfun()函数传递参数的问题。\r\n整合函数如下：\r\n\r\n\r\n遗传算法识别响应函数\r\n\r\n%遗传算法识别响应函数%%遗传算法参数设置% Parameterspop_size = 1000;gene_length = 8;mutation_rate = 0.01;generations = 1000;fitness_threshold = 0.01;%循环终止条件for k = 1:365c = Y(k);d = X(k);% Run Genetic Algorithm[best_individual,final_population] = genetic_algorithm(pop_size, gene_length, mutation_rate, generations,c,d,fitness_threshold);ans(1,k) = bin_dec(best_individual);%disp(ans(1,k));end%初始种群function population = initialize_population(pop_size, gene_length)    population = randi([0, 1], pop_size, gene_length);end%%适应度计算function fit = fitness(decimal,c,d)     fit = abs(c-decimal*d);end%%选择function selected_population = selection(population_decimal, fitnesses,population)    total_fitness = sum(fitnesses);    probabilities = 1 - fitnesses / total_fitness;    selected_indices = randsample(1:length(population_decimal), length(population_decimal), true, probabilities);    selected_population = population(selected_indices,:);    %disp(population);end%%交叉function [offspring1, offspring2] = crossover(parent1, parent2)    point = randi([1, length(parent1) - 1]);    offspring1 = [parent1(1:point), parent2(point+1:end)];    offspring2 = [parent2(1:point), parent1(point+1:end)];end%%变异function mutated_individual = mutate(individual, mutation_rate)    mutation_mask = rand(size(individual)) &lt; mutation_rate;    mutated_individual = xor(individual, mutation_mask);end%%生成下一代function new_pop = new_generation(population, mutation_rate)    new_pop = zeros(size(population));    for i = 1:2:length(population)        parent1 = population(i,:);        parent2 = population(i+1,:);        [offspring1, offspring2] = crossover(parent1, parent2);        new_pop(i, :) = mutate(offspring1, mutation_rate);        new_pop(i+1, :) = mutate(offspring2, mutation_rate);    endend%二进制转化function decimal = bin_dec(population_row)    % Assuming population_row is a row vector    if length(population_row) &lt; 8        error(&#x27;Population vector must be at least 8 bits long.&#x27;);    end        int_part = population_row(1:5); % First 5 bits for integer part    frac_part = population_row(6:8); % Next 3 bits for fractional part    % Convert the integer part    decimal_int = 0;    for i = 1:length(int_part)        decimal_int = decimal_int + int_part(i) * 2^(length(int_part) - i);    end    % Convert the fractional part    decimal_frac = 0;    for i = 1:length(frac_part)        decimal_frac = decimal_frac + frac_part(i) * 2^(-i);    end    % Combine integer and fractional parts    decimal = decimal_int + decimal_frac;end%%%主函数function [best_individual,final_population] = genetic_algorithm(pop_size, gene_length, mutation_rate, generations,c,d,fitness_threshold)    population = initialize_population(pop_size, gene_length);    for gen = 1:generations        for i = 1:pop_size            population_decimal(i) = bin_dec(population(i,:));        end        fitnesses = arrayfun(@(individuals) fitness(individuals,c,d), population_decimal);        max_fitness = max(fitnesses);        %        if max_fitness &lt; fitness_threshold            break;        end        %&#125;        population = selection(population_decimal, fitnesses, population);        population = new_generation(population, mutation_rate);        %fprintf(&#x27;Generation %d: Max Fitness = %d\\n&#x27;, gen, min(fitnesses));    end    final_population = population;    %    for i = 1:length(final_population)        population_decimal(i) = bin_dec(final_population(i,:));    end    fitnesses = arrayfun(@(individuals) fitness(individuals,c,d), population_decimal);    [~, max_fitness_index] = min(fitnesses);    % Get the individual with the highest fitness    best_individual = final_population(max_fitness_index, :);    %&#125;end\r\n\r\n模型检验\r\n选取2010-2014年间任一场洪水，检验所得数据精确性。经分析，决定选取2013-9-22——2013-9-29为检验期。由上述模型得到的参数进行检验，得到下图结果。\r\n\r\n\r\n\r\n梁庚辰,J.E.Nash.大流域汇流演算的线性扰动模型[J].水力发电学报,1991,(02):14-28.↩︎\r\n《工程水文学》,2005,叶守则,詹道江.↩︎\r\n\r\n\r\n","tags":["课设"]},{"title":"本科毕业设计","url":"/2024/10/24/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/","content":"风光抽蓄调度\r\n针对新能源消纳问题，研究抽蓄电站备用库容分级控制对发电效益和负荷波动的优化。\r\n有以下几个问题需要解决：\r\n\r\n旋转备用是什么？\r\n\r\n旋转备用，是指在线但不加载的发电容量，可以在10分钟内补偿由于其他发电机或者变压器故障导致的发电缺口。确定旋转备用的合理分配主要是根据两点：准确可靠的需求预测和经济形势。通常旋转备用是以各时段内最大需求的百分比形式给出的。\r\n\r\n适应性调度是什么？\r\n\r\n自适应调度是指在满足不同工作方式相对优先级的条件下，在设计范围内，同时实时地平衡各种波束请求所要求的时间、能量和计算机资源，为一个调度间隔选择一个最佳任务序列的一种调度方法。这种调度策略能够与动态的环境相适应，与规定的不同工作方式优先级相适应，与可用的时间、能量和计算机资源量相适应。针对多任务或者多功能雷达，自适应调度策略被认为是最灵活最有效的调度策略。适应性调度指在不同约束条件下，抽水蓄能电站发电应该根据不同调度方案进行调度，以期达到整体调度结果的优化。在本文中，根据不同等效负荷设置不同调度方案可以提高抽蓄电站在不同发电约束下的适应性。\r\n\r\n等效负荷是什么？怎么划分？\r\n\r\n剩余负荷：电力供应方提供的电力大于用户实际消耗电力的部分实际负荷：是指电力系统在某一时刻或时间段内实际消耗的电能总量。等效负荷：电网总负荷-除抽蓄外的所有 经过简单统计，由于季节变化，风光储的等效负荷出现了很明显的季节性，所以可以考虑按照水文年划分等效负荷分级。高等效负荷：负荷大于负荷最大值的80%以上\r\n\r\n备用库容怎么划分？\r\n\r\n根据已有文献，备用库容大多按照正常库容的百分比进行划分，此处依然先考虑按照百分比进行划分。但是考虑引入参数对比在同一等效负荷情况下不同百分比划分对优化结果的影响。\r\n\r\n数据资料有华中地区及四个省的发电负荷，该如何使用？\r\nRLV、发电、协调最优分别需要如何计算？\r\n\r\n代码编写\r\n代码编写整体逻辑\r\n\r\n设置循环改变备用库容组合，由于上下库均分两级调度，故需要 \\(2\\times 2\\)共四层循环\r\n定义备用库容占比常数，用于后续计算\r\n从“实际负荷和日最大峰谷差对应剩余符合”表中获取负荷数据，定义如下变量：\r\n      act_load:实际负荷和日最大峰谷差对应剩余负荷数据表\r\n\r\n            al_hunan:湖南省实际负荷数据\r\n            rem_load:剩余负荷数据\r\n            dyna_bene:发电效益数据表\r\n            D_B:发电效益数据\r\n            RLV:日最大峰谷差数据\r\n从\r\n“抽水蓄能电站水位-库容关系“表中获取电站库容数据，定义如下变量：\r\n        LevelCapacity:水库水位-库容关系数据表\r\n            levcap:水库水位-库容关系数据\r\n            Zu:上水库水位\r\n            Vu:上水库库容\r\n            Zd:下水库水位\r\n            Vd:下水库库容\r\n并定义函数 Z_u(v)，Z_d(v)作为上、下库的水位-库容关系曲线插值函数\r\n\r\n将计算约束设置为罚函数形式。首先定义如下变量：\r\n      D:时段数\r\n\r\n            dh:水头损失\r\n            y_g:发电效率\r\n            y_p:抽水效率\r\n            generator_om:发电工况 x\r\n            pumping_om:抽水工况 y\r\n            power:功率 p\r\n由于樽海鞘群算法首先需要随机生成初始种群，现定义生成初始种群矩阵为\r\nin_，其大小为\r\n(1000,3*96)。本次优化设置三个决策变量，分别为发电工况、抽水工况、功率。由于选取典型日作为计算数据，取\r\n15min 为一步长，则全天有 96 个时段，每一决策变量需要有 96\r\n个值，因此，取种群矩阵 in_的前 96 行作为发电工况的初始种群，97-192\r\n行作为抽水工况的初始种群，193-288 行作为功率的初始种群。\r\n然后设置各变量取值范围。 1、库容\r\n限制上下库容在起调库容至最大库容之间，上库库容范围为死库容+备用库容至正常蓄水位，下库库容范围为死库容至正常库容-备用库容。放宽库容罚函数限制至库容上下限\r\n5%。 2、发电抽水工况 当抽水工况为 1\r\n时，设置功率为-1200MW，当抽发工况均为 0 时，设置功率为\r\n0，其余时间功率作为变量进行优化。 - 计算变量对目标函数的适应度 -\r\ngenerator_om:发电工况 x\r\n            pumping_om:抽水工况 y\r\n            power:功率 p\r\n            Rem:优化后剩余负荷 R_\r\nfit_1 作为发电效益目标，fit_2 为剩余负荷波动。\r\nfit_1=-(c_g*z+(-c_p*pumping_om*1200).sum())/400000\r\nc_g 为发电效益，c_p 为抽水成本，且由于 python\r\n定义优化最值为最小值，故在发电效益最大目标中需要在最前面加上负号。z 为\r\n96 个步长的总发电量。\r\n\r\nPareto 最优解判断\r\n\r\n判断当前时段适应值是否会被历史最优解完全支配\r\n判断当前时段适应值是否会被前沿解完全支配\r\n计算repository 集\r\n\r\n\r\n__init__函数：初始化类的局部变量\r\nnext_函数：前移游标位置，并返回游标当前位置的樽海鞘坐标、适应度\r\nhasNext 函数：判断是否已经检查完所有樽海鞘\r\nremove\r\n函数：将非优解从数据集删除，避免重复比较【游标回退-1并将非优解个数+1，变动后的游标和非优解个数用于计算\r\nhasNext 函数】\r\npareto 函数：判断当前樽海鞘是否为 Pareto 最优\r\n\r\n樽海鞘领导者选择：网格法\r\n\r\ncal_mesh_id\r\n函数：计算网格编号【按照等分因子进行等分离散化，并获取樽海鞘在各维度上的编号】\r\ndivide_archiving\r\n函数：进行网格划分，为每个樽海鞘定义网格编号【即对每一樽海鞘使用\r\ncal_mesh_id 函数】\r\nget_crowd\r\n函数：计算拥挤度【先定义一个数组存放樽海鞘集的索引号，再将循环中与索引号数组第一位相同的樽海鞘的索引号放入新的数组，计算新数组的长度，更新拥挤度并删除本轮循环计算完成的索引号（栈）】\r\nget_probability\r\n函数：计算被选为种群领导者的概率【拥挤度越低概率越大】\r\nnon_dominated_sorting 函数：用于计算非支配排序【】\r\ndominate 函数：检查 solution1 是否支配 solution2\r\nget_gbest：选择领导者\r\n\r\n存档集清除溢出最优解\r\n\r\nget_probability 函数：计算清除概率\r\nget_clear_index 函数：按概率清除樽海鞘，拥挤度越高清除概率越高\r\nclear_函数：清除存档集内樽海鞘的所有信息\r\n\r\n初始化种群，更新樽海鞘信息，运行程序\r\n\r\n__init__函数：初始化计算所需的所有参数\r\nevaluation_fitness\r\n函数：计算所有樽海鞘的罚函数和目标函数适应度，并将罚函数加入适应值（降低适应值）\r\ninitialize 函数：初始化樽海鞘坐标【初始化\r\nin_数组作为初始种群，适应度，repository 存档集，领导者】\r\ninit_in\r\n函数：初始化决策变量【发电抽水变量需要满足只能抽或发或不抽不发，功率连续变量仅有上下限约束，即令其随机取上下限内任意值】\r\nupdate_in 函数：更新樽海鞘位置【抽发变量需满足 0-1\r\n变量要求，功率变量更新需要在上下限内】\r\ncompare_pbest 函数：计算各樽海鞘间的支配关系【依据Pareto\r\n支配原理更新】\r\nupdate_pbest 函数：更新历史最优解\r\nUpdate_archive 函数：依据支配关系更新 repository 集\r\nupdate_gbest 函数：更新领导者\r\nupdate_函数：更新樽海鞘所有相关信息\r\nruncode 函数：运行樽海鞘群算法寻优程序【初始化剩余负荷（Excel\r\n数据），初始化樽海鞘群（initialize 函数），初始化存档数据（赋\r\n0），并整理 Pareto 前沿】\r\n\r\n主程序入口：函数和类的实参定义，并将计算数据写入 Excel 表格\r\n\r\n导入计算所需要的库\r\nimport numpy as npimport randomimport pandas as pdimport mathfrom tqdm import tqdmimport timeimport matplotlib.pyplot as plt#from scipy import interpolate\r\n其中，在计算过程中需要用到积分函数interpolate.trazp，首先导入scipy。但是由于python库的提供网站已经停止使用，导致python\r\n3.12配套的twisted.whl和scipy.whl都无法下载。尝试降低python版本到3.11后，scipy包文件有缺失，无法正常使用interpolate.trapz，故选择numpy的trapz作为替代，不再使用scipy库。\r\n获取计算数据\r\n\r\n\r\n目标函数\r\n\r\n&#x27;&#x27;&#x27;act_load:实际负荷和日最大峰谷差对应剩余负荷数据表al_hunan:湖南省实际负荷数据rem_load:剩余负荷数据dyna_bene:发电效益数据表D_B:发电效益数据RLV:日最大峰谷差数据&#x27;&#x27;&#x27;np.set_printoptions(suppress=True,linewidth=160,nanstr=None,formatter=&#123;&#x27;float&#x27;:&#x27;&#123;:&gt;2&#125;&#x27;.format&#125;) #设置打印格式r1_path=r&quot;实际负荷和日最大峰谷差对应剩余负荷.xlsx&quot;   #剩余负荷出力数据储存路径act_load=pd.ExcelFile(r1_path)al_hunan=pd.read_excel(act_load, sheet_name=&quot;湖南&quot;,header=[0,1]) #第0行和第1行作为列索引dyna_bene=pd.read_excel(act_load, sheet_name=&quot;发电效益&quot;,header=0) #第0行作为列索引rem_load=[] #创建新数组用于存储剩余负荷数据for i in range(1,13):    rem_load.append(al_hunan[f&#x27;&#123;i&#125;月&#x27;][&#x27;扣除风光&#x27;].values) #将每个月的剩余负荷数据存入列表 rem_load=np.array(R0) #将列表转换为数组D_B=dyna_bene[&#x27;发电效益(万美元)&#x27;].values #获取发电效益数据RLV=dyna_bene[&#x27;RLV实际&#x27;].values #获取日最大峰谷差数据&#x27;&#x27;&#x27;LevelCapacity:水库水位-库容关系数据表levcap:水库水位-库容关系数据Zu:上水库水位Vu:上水库库容Zd:下水库水位Vd:下水库库容&#x27;&#x27;&#x27;r2_path=r&quot;抽水蓄能电站水位-库容关系.xlsx&quot;   #水电站水库数据储存路径LevelCapacity=pd.ExcelFile(r2_path) #读取水库水位-库容关系数据levcap=pd.read_excel(LevelCapacity, sheet_name=0,header=[0,1])Zu=levcap[&#x27;上水库&#x27;,&#x27;水位（m)&#x27;].loc[levcap[&#x27;上水库&#x27;,&#x27;水位（m)&#x27;].notnull()].valuesVu=levcap[&#x27;上水库&#x27;].loc[levcap[&#x27;上水库&#x27;,&#x27;库容(m3)&#x27;].notnull(),&#x27;库容(m3)&#x27;].values/10000Zd=levcap[&#x27;下水库&#x27;].loc[levcap[&#x27;下水库&#x27;,&#x27;水位（m)&#x27;].notnull(),&#x27;水位（m)&#x27;].valuesVd=levcap[&#x27;下水库&#x27;].loc[levcap[&#x27;下水库&#x27;,&#x27;库容(m3)&#x27;].notnull(),&#x27;库容(m3)&#x27;].values/10000#上水库水位-库容关系曲线(库容单位万立方米)def Z_u(v):    zu=np.interp(v,Vu,Zu) #线性插值，v为库容，Vu为上水库库容，Zu为上水库水位    return round(zu,1) #返回水位值#下水库水位-库容关系曲线(库容单位万立方米)def Z_d(v):    zd=np.interp(v,Vd,Zd)    return round(zd,1)\r\n\r\n通过本地excel文件获取数据，并命名。\r\n编写罚函数\r\n\r\n\r\n罚函数\r\n\r\n&#x27;&#x27;&#x27;D:时段数dh:水头损失y_g:发电效率y_p:抽水效率generator_om:发电工况 xpumping_om:抽水工况 ypower:功率 p&#x27;&#x27;&#x27;# in_=[x,y,p] x为发电工况，y为抽水工况，p为功率 还未实现#罚函数计算(所有罚函数存储于输出结果的列表中，每个元素代表一个罚函数)# =============================================================================def penalty(in_,D=96,dh=7,y_g=0.85,y_p=0.88):      e=[]    Vu=[71.36]    #上库起调库容(死库容)    Vd=[960.04]   #下库起调库容(正常库容)    #决策变量分割    generator_om=np.copy(in_)[:D]  #发电工况    pumping_om=np.copy(in_)[D:2*D] #抽水工况    power=np.copy(in_)[2*D:] #功率    for i in range(D):        if pumping_om[i]==1 :            power[i]=-1200        if generator_om[i]==0 and pumping_om[i]==0 :            power[i]=0    #计算各时段的上下库库容，分别保存于对应列表中    for i in range(len(p)):        vu=Vu[i]        vd=Vd[i]        zu=Z_u(vu)        zd=Z_d(vd)        if power[i]&gt;0 :            H=zu-zd-dh   #发电水头            Q=power[i]*10**3/(9.81*y_g*H)   #发电流量(注意功率单位为MW，而水量转换中功率单位为KW)        else:            H=zu-zd+dh   #抽水扬程            Q=power[i]*10**3*y_p/(9.81*H)   #抽水流量(注意功率单位为MW，而水量转换中功率单位为KW)        vu-=Q*15*60/10000        vd+=Q*15*60/10000        Vu.append(vu)        Vd.append(vd)        #考虑罚函数的库容范围为死库容和正常库容的5%范围内        e1 = max(0, vu-917.34*1.05) # 比较库容和上水库最大库容的差值与上水库最大库容的5%的大小        e2 = max(0, 71.36*0.95-vu) # 比较上水库最小库容的5%与库容的差值的大小        e3 = max(0, vd-960.04*1.05) # 比较库容和下水库最大库容的差值与下水库最大库容的5%的大小        e4 = max(0, 91.71*0.95-vd) # 比较下水库最小库容的5%与库容的差值的大小        e.extend([e1,e2,e3,e4]) # 将四个罚函数值添加到e列表中        if i==len(p)-1 : #最后一个时段            e5=max(0,abs(vd-960.04)-0.05*960.04)            e.append(e5)             return e\r\n\r\n目标函数\r\n\r\n\r\n目标函数\r\n\r\n&#x27;&#x27;&#x27;generator_om:发电工况 xpumping_om:抽水工况 ypower:功率 pRem:优化后剩余负荷 R_&#x27;&#x27;&#x27;#self：python中类的方法必须包含self参数，且必须位于其他参数之前# =============================================================================#目标函数def fitness(in_,rem_load,D=96,c_g=50,c_p=17): #D为时段数，R0为剩余负荷，c_g为发电效益，c_p为抽水成本系数    generator_om=np.copy(in_)[:D] #0-95列代表发电工况 （1000，96）    pumping_om=np.copy(in_)[D:2*D] #96-191代表抽水工况    power=np.copy(in_)[2*D:] #192-287代表功率    Rem=rem_load-generator_om*power+pumping_om*1200 #优化后剩余负荷    for i in range(D):        if pumping_om[i]==1 :            power[i]=-1200        if generator_om[i]==0 and y[i]==0 :            power[i]=0        a=np.linspace(1,96,96).astype(int)    z=np.trapz(generator_om*power,a) #发电量        fit_1 = -(c_g*z+(-c_p*pumping_om*1200).sum())/40000    #发电效益最大(注意功率单位为MW，则效益单位为万美元)    fit_2 = (((Rem-Rem.mean())**2).mean())**0.5/(((rem_load-rem_load.mean())**2).mean())**0.5    #剩余负荷波动最小    return [fit_1,fit_2]\r\n\r\n计算代码\r\n本文采用多目标樽海鞘算法进行优化求解，已有代码为多目标粒子群算法。粒子群算法由Dr.Eberhart和Dr.Kennedy于1995年提出，模仿鸟群觅食改进对可行域中最优解的搜索；樽海鞘算法由Dr.Seyedali\r\nMirjalili于2017年提出，模仿樽海鞘群的行动优化最优解的搜索。对于多目标问题而言，两者的相似之处在于都采用了Pareto前沿仓库作为优化的策略，但二者还有很大不同：\r\n\r\n粒子位置更新方式的不同：\r\n多目标粒子群算法（MOPSO）通常使用传统的粒子群优化算法中的位置更新策略，即基于个体最优解（pbest）和全局最优解（gbest）来引导粒子的运动。\r\n多目标樽海鞘算法（MOMPSO）则在此基础上增加了对Pareto前沿的引导。每个粒子不仅关注其个体最优解和全局最优解，还会考虑距离Pareto前沿的距离（或目标空间的“非支配”关系），这有助于提高解的多样性和分布性。\r\nPareto前沿的处理：\r\n在MOPSO中，通常会采用拥挤度比较等方法来保持解集的多样性，但不会特别强调解的“分布性”，更多依赖全局最优解来引导粒子的搜索过程。\r\nMOMPSO则更加注重解的分布性，特别是通过引入“樽海鞘”的概念（类似于对Pareto前沿的高密度区域进行压制，保持低密度区域的探索），使得粒子群在搜索过程中能够更好地找到覆盖整个Pareto前沿的解，避免解过于集中或重叠。\r\n拥挤度比较和多样性维护：\r\nMOPSO通常使用“拥挤度”策略来维持解的多样性，拥挤度是衡量解在目标空间中的密集程度的一个指标。粒子在更新位置时，会避免与其他粒子过于接近，从而确保解的分布尽量均匀。\r\nMOMPSO则通过更加精细的“支配关系”处理和樽海鞘的概念来维护解集的多样性。例如，粒子不仅要优化目标函数的值，还要在Pareto前沿的“空白”区域探索，以避免在解空间中过于集中。\r\n非支配排序和选择机制：\r\n在MOPSO中，通常会结合非支配排序或Crowding距离来选择解，这有助于在多个目标之间找到一个平衡点，使得算法能够找到一个适合多目标优化的解集。\r\n在MOMPSO中，选择机制更加注重Pareto前沿的结构，粒子会根据与Pareto前沿的距离或支配关系来更新解集，以确保解集的多样性和均匀性。\r\n更新过程中的参考点或归约策略：\r\nMOPSO的更新过程主要依赖个体最优解（pbest）和全局最优解（gbest），有时也会引入一些参考点，但核心是粒子之间的协作与竞争。\r\nMOMPSO则更强调“Pareto最优”解集的结构性更新，它通常通过一种“归约”机制来从多个非支配解中选出具有代表性的解，从而更好地覆盖整个目标空间。\r\n算法目标：\r\nMOPSO的目标是找到一组平衡的解，这些解能够在多个目标之间取得较好的妥协，但多样性和分布性可能不如MOMPSO。\r\nMOMPSO的目标是更加注重Pareto前沿的分布性，不仅要优化目标函数的值，还要确保解在Pareto前沿的均匀分布。\r\n\r\n综上所述，MOMPSO的多目标优化算法通过更强的结构性指导和Pareto前沿的优化提高了搜索性能。在代码上，主要表现为更改了最优点选取和拥挤度计算。\r\n\r\nPareto最优解选择 主要修改：\r\n\r\n非支配排序：在MOMPSO中，不仅要根据网格划分，还要对粒子进行非支配排序（Non-Dominated\r\nSorting）。即，我们需要找到非支配解，并通过拥挤度（Crowding\r\nDistance）来衡量解集的多样性。\r\nPareto最优解选择：更新gbest时不仅考虑适应度，还需要考虑其在Pareto前沿上的位置以及在解空间中的分布性。\r\n\r\n拥挤度计算\r\n在MOMPSO中，拥挤度的计算不仅仅是基于每个粒子在网格中的位置，而是通过考虑粒子在目标空间中的相对位置来进行的。每个目标维度都会单独进行排序并计算粒子间的差值，粒子在稀疏区域的拥挤度会更高，从而保证解集的分布性。通过这种方式，MOMPSO在多目标优化中能够保持更好的解的多样性，避免解过于集中，从而更有效地探索Pareto前沿。具体修改见如下代码。\r\n代码改动方案：\r\n\r\n引入非支配排序（Non-Dominated Sorting）：\r\n为了实现非支配排序，我们需要实现一种方法来对粒子进行排序，并根据其支配关系计算拥挤度。\r\n具体代码中的改进：\r\n\r\n选择更新（更新gbest）：\r\n选择粒子时，考虑不仅仅是适应度和网格划分，还要考虑其在Pareto前沿上的位置和拥挤度。\r\n\r\n\r\n改进拥挤度计算：\r\n\r\n传统的拥挤度计算方法：\r\n在传统的多目标粒子群优化（MOPSO）中，拥挤度是通过以下方式计算的：\r\n排序：首先，按照每个目标函数的值对存档中的解进行排序。\r\n边界条件：对于每个目标维度的最小值和最大值，赋予粒子极高的拥挤度值（通常是无穷大），确保它们不会被排除。\r\n计算拥挤度：然后，拥挤度值是通过粒子在目标空间中的邻近解的目标值差值来计算的。粒子的拥挤度值越大，表示其附近的解越稀疏，反之，表示解集在该区域较为密集。\r\nMOMPSO中的拥挤度计算改进：\r\n在多目标樽海鞘算法（MOMPSO）中，拥挤度的计算方法改进如下：\r\n基于目标空间的拥挤度：\r\n与MOPSO中的拥挤度计算不同，MOMPSO引入了对每个目标空间维度的排序，并且同时考虑多个目标维度来计算粒子的拥挤度。\r\n对于每个目标，粒子的位置被排序并通过目标空间中的“邻近”粒子之间的距离来计算拥挤度。粒子被放置在更稀疏的区域时，拥挤度值会更高，从而保证解集的多样性。\r\n逐维排序与拥挤度计算：\r\n在计算拥挤度时，MOMPSO通常会对每个目标进行排序，并为每个粒子计算目标维度的“邻近距离”。例如，对于目标1的第一个粒子，它的拥挤度是与目标1上所有其他粒子的相对距离的一个度量。\r\n然后，MOMPSO会将所有目标维度的拥挤度进行组合，粒子的总拥挤度是所有目标维度拥挤度的加权和。\r\n改进的拥挤度值与分布性：\r\nMOMPSO在计算拥挤度时，结合了非支配排序的机制，使得在多目标优化中，粒子不仅要考虑距离近似的解，还要确保解的均匀分布，从而避免粒子集中在解空间的某些区域，导致过度搜索局部最优。\r\nMOMPSO中拥挤度计算的具体改进步骤：\r\n\r\n对每个目标进行排序：\r\n对存档中的每个粒子，根据目标函数值对其进行排序。对于每个目标的排序，粒子会被排序成一个顺序。\r\n计算每个目标的拥挤度：\r\n对于每个目标维度，计算排序后的粒子之间的邻近距离。距离越远的粒子，拥挤度越高，表示该区域更为稀疏；而距离较近的粒子表示该区域更为拥挤。\r\n组合拥挤度：\r\n对于每个粒子，综合考虑所有目标的拥挤度。通常，MOMPSO会将每个维度的拥挤度值加权或进行某种形式的归一化，以确保不同目标维度之间的平衡。\r\n选择解时使用拥挤度：\r\n在选择解时，MOMPSO会结合非支配排序和拥挤度来保证解集的分布性。拥挤度低的解（即分布较稀疏的区域）会有更大的机会被选为gbest。\r\n\r\n\r\n\r\n\r\n\r\nMOMPSO寻优\r\n\r\n# MSSA算法=============================================================================# 全局粒子寻优=============================================================================class MOMPSO:    def __init__(self, curr_archiving_in, curr_archiving_fit, curr_archiving_e, mesh_div_num, min_, max_, particals):        self.curr_archiving_in = curr_archiving_in  # 当前存档中所有粒子的坐标        self.curr_archiving_fit = curr_archiving_fit  # 当前存档中所有粒子的适应度        self.curr_archiving_e = curr_archiving_e  # 当前存档中所有粒子的罚函数        self.mesh_div = mesh_div_num  # 等分因子        self.num_ = self.curr_archiving_in.shape[0]  # 存档集(archive)的粒子数量        self.particals = particals  # 粒子群算法生成的粒子数量        self.id_archiving = np.zeros((self.num_))  # 各个粒子的id编号        self.crowd_archiving = np.zeros((self.num_))  # 拥挤度矩阵        self.probability_archiving = np.zeros((self.num_))  # 各个粒子被选为gbest的概率        self.gbest_in = np.zeros((self.particals, self.curr_archiving_in.shape[1]))  # 初始化gbest矩阵_坐标        self.gbest_fit = np.zeros((self.particals, self.curr_archiving_fit.shape[1]))  # 初始化gbest矩阵_适应值        self.gbest_e = np.zeros((self.particals, self.curr_archiving_e.shape[1]))  # 初始化gbest矩阵_罚函数        self.min_ = min_        self.max_ = max_        self.divide_archiving()        self.get_crowd()    def cal_mesh_id(self, in_):  # 计算网格编号id        id_ = 0        for i in range(self.curr_archiving_in.shape[1]):  # 按照等分因子进行等分离散化，获取粒子在各维度上的编号            id_dim = int((in_[i] - self.min_[i]) / (self.max_[i] - self.min_[i]) * self.num_)            id_ = id_ + id_dim * (self.mesh_div ** i)        return id_    def divide_archiving(self):  # 进行网格划分，为每个粒子定义网格编号        for i in range(self.num_):            self.id_archiving[i] = self.cal_mesh_id(self.curr_archiving_in[i])    def get_crowd(self):  # 计算拥挤度     index_ = (np.arange(0, self.num_)).tolist()  # 定义一个数组存放粒子集的索引号     while len(index_) &gt; 0:  # 计算拥挤度        index_same = [index_[0]]  # 存放本次子循环中与index[0]粒子具有相同网格id所有检索位        for i in range(1, len(index_)):             if self.id_archiving[index_[0]] == self.id_archiving[index_[i]]:  # 与index[0]粒子具有相同网格id                index_same.append(index_[i])  # 存放本次子循环中与index[0]粒子具有相同网格id所有检索位        number_ = len(index_same)  # 本轮网格中的总粒子数        for i in index_same:  # 更新本轮网格id下的所有粒子的拥挤度(密度)            self.crowd_archiving[i] = number_            index_.remove(i)  # 删除本轮网格所包含的粒子对应的索引号，避免重复计算    def get_probability(self):  # 计算被选为gbest的概率        for i in range(self.num_):            self.probability_archiving[i] = 10.0 / (self.crowd_archiving[i] ** 3)        self.probability_archiving = self.probability_archiving / np.sum(self.probability_archiving)    def non_dominated_sorting(self):  # 非支配排序        #进行非支配排序，将存档中的粒子分为多个等级        rank = np.zeros(self.num_, dtype=int)  # 存储每个粒子的排序等级        fronts = [[]]  # 存储各个前沿的粒子        domination_count = np.zeros(self.num_, dtype=int)  # 支配计数        dominated_solutions = [[] for _ in range(self.num_)]  # 存储每个粒子所支配的粒子                for p in range(self.num_):            for q in range(self.num_):                if self.dominates(self.curr_archiving_fit[p], self.curr_archiving_fit[q]):                    dominated_solutions[p].append(q)                elif self.dominates(self.curr_archiving_fit[q], self.curr_archiving_fit[p]):                    domination_count[p] += 1                        if domination_count[p] == 0:                rank[p] = 0                fronts[0].append(p)                i = 0        while len(fronts[i]) &gt; 0:            next_front = []            for p in fronts[i]:                for q in dominated_solutions[p]:                    domination_count[q] -= 1                    if domination_count[q] == 0:                        rank[q] = i + 1                        next_front.append(q)            i += 1            fronts.append(next_front)                return rank, fronts    def dominates(self, solution1, solution2):        &quot;&quot;&quot;检查solution1是否支配solution2&quot;&quot;&quot;        better = False        for i in range(len(solution1)):            if solution1[i] &gt; solution2[i]:                return False            elif solution1[i] &lt; solution2[i]:                better = True        return better    &#x27;&#x27;&#x27;    3. gbest 的选择方式    通常，选择全局最优解（gbest）的策略不仅仅依赖于一个粒子的表现，还可能结合多种标准，例如粒子的适应度值、拥挤度、支配关系等。在该代码段中，循环选择 best_front 中的粒子，意味着：    每次迭代可能都会选择一个来自 第一前沿 的粒子作为 gbest。    由于粒子是循环选择的，所以每个粒子都有可能在不同的代成为 gbest，这种选择方式帮助算法更全面地探索解空间。    &#x27;&#x27;&#x27;    def get_gbest(self):  # 获取gbest的坐标、适应值、罚函数        # 进行非支配排序        rank, fronts = self.non_dominated_sorting()                # 对于每个前沿，使用拥挤度来选择解        best_front = fronts[0]  # 第一前沿最优        &#x27;&#x27;&#x27;        best_front通常表示非支配排序后的前沿。在多目标优化中，解集通常会被分为多个前沿（Front），其中：        第一前沿（best_front） 是非支配的解，即这些解在所有目标上都不被其他解支配（即没有任何其他解能在所有目标上同时优于这些解）。        第二前沿、第三前沿 等是依次支配关系更弱的解集，通常解集的质量逐步下降。        通过非支配排序，我们把存档中的解分成了多个不同的前沿（fronts），而第一前沿是质量最好的解。        &#x27;&#x27;&#x27;        for i in range(self.particals):            chosen_index = best_front[i % len(best_front)]            &#x27;&#x27;&#x27;            chosen_index = best_front[i % len(best_front)] 的含义            这段代码的作用是从第一前沿（best_front）中选取一个粒子来作为全局最优解（gbest）。具体来说：            best_front[i % len(best_front)] 意味着按顺序循环访问 第一前沿 中的粒子。这是一个模运算，表示循环地选择前沿中的粒子。            i 是一个迭代变量，通常是在一个循环中自增。            len(best_front) 是 第一前沿中解的个数。            i % len(best_front) 就是将 i 限制在 best_front 中粒子个数的范围内。如果 i 大于 len(best_front)，则会从头开始循环选择。            &#x27;&#x27;&#x27;            self.gbest_in[i] = self.curr_archiving_in[chosen_index]            self.gbest_fit[i] = self.curr_archiving_fit[chosen_index]            self.gbest_e[i] = self.curr_archiving_e[chosen_index]                return self.gbest_in, self.gbest_fit, self.gbest_eprint(&#x27;全局粒子寻优完成&#x27;)    &#x27;&#x27;&#x27;    这种方式有三个好处    1、通过循环选择，可以确保解的多样性，避免集中于某个特定粒子。    2、它增强了算法的探索性，并提供了平衡探索和利用的机制。    3、通过选择多个解而非单一解，可以帮助避免过早收敛到局部最优解。    &#x27;&#x27;&#x27;\r\n\r\n主函数\r\n\r\n\r\n主函数\r\n\r\n\r\n\r\n\r\n画图\r\n\r\n需要修改的模块\r\n\r\nget_probability 函数\r\n删除速度更新函数\r\n更改位置更新函数\r\n更改离散变量的位置更新函数\r\n更改参数值\r\n\r\n\r\n备用库容划分\r\n划分思路\r\n如果抽水蓄能电站需要提供较高的等效负荷，备用库容的占比通常应该较大。\r\n原因如下：\r\n1. 负荷需求的增加：\r\n当电网对抽水蓄能电站的调节能力（即负荷需求）要求较高时，电站需要更频繁地进行发电或抽水操作。这意味着电站需要有足够的可调节容量，以应对快速的负荷波动或者应急情况。因此，备用库容作为电站应急调节能力的储备，必须相对增大，以便在需要时能够迅速调动更多的水量进行发电或抽水。\r\n2.\r\n应急备用和快速响应能力：\r\n较高的等效负荷意味着电站可能面临更加复杂的运行调度，备用库容可以为电站提供必要的安全裕度。在负荷波动或突发情况下，备用库容可以保证电站在发生设备故障、外部需求急剧变化等情况下，仍能保持稳定运行。备用库容较大的话，有助于在高负荷期间提供更长时间的发电支持或抽水操作，从而增强系统的安全性和可靠性。\r\n3. 调度灵活性：\r\n如果电站要提供较高的等效负荷，它通常需要更高的调节灵活性，以便根据电网的需求做出响应。这就要求电站有足够的备用库容，以应对负荷变化对水库水位的影响，保证水库在不降低电站整体效率的前提下，仍能快速响应负荷需求。\r\n4. 长周期调节能力：\r\n当电站在高等效负荷下运行时，可能需要长时间的稳定调节，这也意味着备用库容需要足够大，以避免因电站负荷变化或设备故障等因素而导致电站无法正常运行。\r\n综合考虑：\r\n\r\n高等效负荷下，电站可能需要在短时间内迅速提高发电量或储水能力，这要求备用库容能够支撑高频次、高强度的负荷调节。因此，备用库容占比通常应增加，以提高电站的应急响应和调节能力。\r\n\r\n结论：\r\n当抽水蓄能电站的等效负荷较高时，备用库容的占比应相应增大，以确保电站具有更好的灵活性、可靠性和应急响应能力，从而能够满足电网的高需求并应对突发情况。\r\n\r\n\r\n为什么负荷越高备用库容要求越高\r\n\r\n等效负荷越高，备用库容的占比通常应该更高，尤其是在只考虑备用功能的情形下。下面详细解释原因：\r\n\r\n等效负荷和备用库容的关系\r\n\r\n\r\n等效负荷通常是指电站在某个时刻的负荷需求。它考虑了电站的实际需求以及负荷波动、备用容量需求等因素。\r\n备用库容是电站为了应对突发事件（如机组故障、电力需求激增等）所储备的水量，用来在应急情况下提供快速的备用电力输出。\r\n\r\n\r\n等效负荷高时的需求\r\n\r\n当等效负荷高时，意味着电站面临较大的负荷需求或者较高的负荷波动。为了应对这些负荷需求，备用库容的作用显得尤为重要。特别是在只考虑备用功能的情况下，备用库容需要更多的储备，以保证：\r\n\r\n当负荷需求急剧上升时，备用电力能够迅速释放。\r\n确保在突发事件发生时（如机组故障、系统事故等），备用容量能够及时响应，避免系统电力供应中断。\r\n\r\n\r\n备用库容的作用\r\n\r\n备用库容的主要作用是作为应急备用，而不是在日常调度中参与负荷的常规调节。当等效负荷较高时，电站的系统稳定性要求较高，这时备用库容需要更大，以应对极端负荷波动或设备故障。\r\n\r\n为什么备用库容占比应该更高？\r\n\r\n\r\n负荷波动增大：等效负荷高通常意味着负荷波动或需求大，备用库容需要更大以应对这些变化。\r\n应急响应需求更强：在高负荷情况下，电站的备用电力需求增加。备用库容需要确保能够在短时间内释放足够的电力来应对突发的高负荷情况。\r\n安全系数更高：高等效负荷往往意味着电网负荷接近满载或系统风险较高，为了增加系统安全性，备用库容需要更大，以提供足够的应急储备。\r\n\r\n\r\n备用库容占比计算的考虑因素\r\n\r\n备用库容的占比并非一个固定的数值，而是受到以下因素的影响：\r\n\r\n等效负荷的大小：负荷越高，备用库容的需求越大。\r\n电网的稳定性要求：如果电网系统的稳定性较为脆弱，需要更大的备用库容。\r\n电站的响应能力：如果电站的响应能力较强（如抽水蓄能电站），备用库容占比可能相对较小；如果电站的响应能力较弱，则需要更大的备用库容。\r\n\r\n结论\r\n在只考虑备用功能（不参与正常调度）的情况下，当等效负荷越高时，为了保证电站的应急响应能力和电网的稳定性，备用库容的占比应该相应地增加。这是因为备用库容的目的是应对高负荷和突发事件，因此负荷需求越大，备用库容的需求也随之增加。\r\n\r\n按照已知数据，可以把全年等效负荷分为两部分，按照全年等效负荷平均值，将其分为大于平均值和小于平均值两部分，即等效负荷&gt;11873.183和等效负荷&lt;=11873.183，按照上述思路，等效负荷较大的部分设置备用库容占比为20%，检验比较递减至15%的改善率，较小部分设置占比5%，检验比较递增至15%的改善率。\r\n约束条件修改以代码895行为例：\r\nif rem_load[i].mean() &lt;= 10000:    Vu=[71.36+845.98*LOW_LOAD_P]    #上库起调库容为正常库容90%else:    Vu=[71.36+845.98*HIGH_LOAD_P]   #上库起调库容为正常库容80%\r\n计算结果\r\nPareto前沿分类及最终方案\r\n\r\n智能算法在动态优化问题的应用\r\n根据《动态多目标优化进化算法及其应用》一书中所提到的约束DMOP测试函数，本文使用K.Den等在解决水热器动力系统问题中构造的一个带复杂约束的双目标动态优化问题，记作测试函数OPF。该函数的数学表达如下：\r\n\\[ \\left\\{\\begin{array}{l}\\min\r\nf(x)=\\left(f_{1}(x), f_{2}(x)\\right), \\quad x=\\left(P_{h t}, P_{s\r\nt}\\right), \\\\f_{1}(x)=\\sum_{t=1}^{M} \\sum_{s=1}^{N_{s}}\r\nt_{T}\\left[a_{s}+b_{s} P_{s t}+c_{s} P_{s t}^{2}+\\mid d_{s} \\sin\r\n\\left\\{\\left(e_{s}\\left(P_{s}^{\\min }-P_{s t}\\right)\\right\\}\r\n\\mid\\right],\\right. \\\\f_{1}(x)=\\sum_{t=1}^{M} \\sum_{s=1}^{N_{s}}\r\nt_{T}\\left[a_{s}+\\beta_{s} P_{s t}+\\gamma_{s} P_{s t}^{2}+\\eta_{s} \\exp\r\n\\left(\\delta_{s} P_{s t}\\right)\\right], \\\\\\sum_{s=1}^{N_{s}} P_{s\r\nt}+\\sum_{h=1}^{N_{s} P_{h t}-P_{D t}-P_{L t}=0, \\quad t=1,2, \\cdots, M,}\r\n\\\\\\sum_{t=1}^{M} t_{T}\\left(a_{0 h}+a_{l h} P_{h t}+a_{2 h} P_{h\r\nt}^{2}\\right)-W_{h}=0, \\quad h=1,2, \\cdots, N_{h}, \\\\P_{s}^{\\min }\r\n\\leqslant P_{s t} \\leqslant P_{s}^{\\max }, \\quad s=1,2, \\cdots, N_{s},\r\n\\quad t=1,2, \\cdots, M, \\\\P_{h}^{\\min } \\leqslant P_{h t} \\leqslant\r\nP_{h}^{\\max }, \\quad h=1,2, \\cdots, N_{h}, \\quad t=1,2, \\cdots,\r\nM,\\end{array}\\right. \\] \\[ 其中，\r\nN_{h}  表示水电发生器  P_{h t}  的个数， N_{s}  表示热熔产生器  P_{s\r\nt}  的个数，且  x=\\left(P_{k t}, P_{s t}\\right), M=T /P_{s\r\nt}  表示在整个作业时间段问题发生变化的总次数  \\left(t_{T}\\right.  表示固定的区间）．作者建议在第  t  个固定区间上，\r\nP_{L}=\\sum_{i=1}^{N_{h}+N_{t}} \\sum_{j=1}^{N_{t}+N_{s}} P_{i t} P_{i j}\r\nP_{j t}  ．另外，该测试函数有  M\\left(N_{s}+N_{h}\\right)  个变量，\r\nM+N_{h}  个等式约束及  2 M\\left(N_{s}+N_{h}\\right)  个变量边界\r\n\\]\r\n遗传算法\r\n首先使用遗传算法解决该问题，具体代码如下：\r\n\r\n\r\n遗传算法\r\n\r\nimport numpy as npfrom deap import base, creator, tools, algorithmsimport randomimport time# 1. 创建多目标优化问题creator.create(&quot;FitnessMulti&quot;, base.Fitness, weights=(-1.0, -1.0))  # 最小化目标creator.create(&quot;Individual&quot;, list, fitness=creator.FitnessMulti)# 2. 定义目标函数 f1(x) 和 f2(x)def evaluate(individual):    # 提取个体的参数    P_s = individual[:N_s * M]    P_h = individual[N_s * M:]        # f1(x) - 热电系统的目标函数    f1 = 0    for t in range(M):        for s in range(N_s):            f1 += t_T[t] * (a_s[s] + b_s[s] * P_s[s * M + t] + c_s[s] * P_s[s * M + t]**2 +                             abs(d_s[s]) * np.sin(e_s[s] * (P_s_min[s] - P_s[s * M + t])))        # f2(x) - 水电系统的目标函数    f2 = 0    for t in range(M):        for s in range(N_s):            f2 += t_T[t] * (a_s[s] + β_s[s] * P_s[s * M + t] + γ_s[s] * P_s[s * M + t]**2 +                             η_s[s] * np.exp(δ_s[s] * P_s[s * M + t]))    # 返回目标函数值    return f1, f2# 3. 定义约束条件def check_constraints(individual):    # 电力平衡约束    P_s = individual[:N_s * M]    P_h = individual[N_s * M:]        # 约束 1: sum(P_s) + sum(P_h) - P_D - P_L = 0    power_balance = np.sum(P_s) + np.sum(P_h) - P_D - P_L    # 约束 2: P_s_min &lt;= P_s &lt;= P_s_max (热电)    for s in range(N_s):        for t in range(M):            if not (P_s[s * M + t] &gt;= P_s_min[s] and P_s[s * M + t] &lt;= P_s_max[s]):                return False  # 违反约束        # 约束 3: P_h_min &lt;= P_h &lt;= P_h_max (水电)    for h in range(N_h):        for t in range(M):            if not (P_h[h * M + t] &gt;= P_h_min[h] and P_h[h * M + t] &lt;= P_h_max[h]):                return False  # 违反约束    # 如果没有违反任何约束，则返回True    return True# 4. 定义个体的初始化和变异操作def create_individual():    # 创建个体，假设每个个体包含 N_s * M 个热电发电量和 N_h * M 个水电发电量    P_s = [random.uniform(P_s_min[s], P_s_max[s]) for s in range(N_s) for t in range(M)]    P_h = [random.uniform(P_h_min[h], P_h_max[h]) for h in range(N_h) for t in range(M)]    return P_s + P_h# 5. 配置遗传算法toolbox = base.Toolbox()toolbox.register(&quot;individual&quot;, tools.initIterate, creator.Individual, create_individual)toolbox.register(&quot;population&quot;, tools.initRepeat, list, toolbox.individual)toolbox.register(&quot;mate&quot;, tools.cxBlend, alpha=0.5)  # 交叉操作toolbox.register(&quot;mutate&quot;, tools.mutGaussian, mu=0, sigma=1, indpb=0.2)  # 变异操作toolbox.register(&quot;select&quot;, tools.selNSGA2)  # 使用NSGA-II选择操作toolbox.register(&quot;evaluate&quot;, evaluate)toolbox.decorate(&quot;evaluate&quot;, tools.DeltaPenalty(check_constraints, 100))# 6. 运行遗传算法def main():    start_time = time.time()  # 开始计时    population = toolbox.population(n=100)  # 初始化种群    algorithms.eaMuPlusLambda(population, toolbox, mu=100, lambda_=200, cxpb=0.7, mutpb=0.2, ngen=50, verbose=True)        end_time = time.time()  # 结束计时    elapsed_time = end_time - start_time  # 计算经过的时间    print(f&quot;Evaluation time: &#123;elapsed_time&#125; seconds&quot;)  # 打印计算时间    return population# 7. 执行并输出结果if __name__ == &quot;__main__&quot;:    # 假设N_s, N_h, M的值已经定义，并设置相关参数    N_s, N_h, M = 5, 5, 10  # 示例值    P_s_min = [10] * N_s    P_s_max = [100] * N_s    P_h_min = [20] * N_h    P_h_max = [150] * N_h    P_D, P_L = 200, 100  # 示例负荷需求    a_s = [0.1] * N_s    b_s = [0.2] * N_s    c_s = [0.3] * N_s    d_s = [0.4] * N_s    e_s = [0.5] * N_s    β_s = [0.6] * N_s    γ_s = [0.7] * N_s    η_s = [0.8] * N_s    δ_s = [0.9] * N_s    t_T = [1] * M  # 假设时间段为1    population = main()    # 获取最优解（非支配前沿）    front = tools.sortNondominated(population, len(population), first_front_only=True)[0]    &#x27;&#x27;&#x27;    # 输出前沿的个体    for ind in front:        print(ind.fitness.values)  # 打印每个个体的目标值    &#x27;&#x27;&#x27;    # 输出最优解    best_ind = tools.selBest(population, 1)[0]    print(&quot;Best individual is: %s\\nwith fitness: %s&quot; % (best_ind, best_ind.fitness.values))\r\n\r\n计算得该算法用时1.982s。\r\nPSO算法\r\n使用PSO算法进行计算，具体代码如下：\r\n\r\n\r\nPSO算法\r\n\r\nimport numpy as npimport randomimport matplotlib.pyplot as pltfrom tqdm import tqdm# 假设有4个热力发电单元和6个时段Ns = 4  # 热力发电单元的数量M = 6   # 时段的数量# 假设每个发电单元的系数（根据实际情况修改）a_s = np.array([100, 120, 140, 160])  # 常数项b_s = np.array([10, 12, 14, 16])      # 线性系数c_s = np.array([0.5, 0.6, 0.7, 0.8])  # 平方项系数d_s = np.array([1.0, 1.1, 1.2, 1.3])  # 正弦项系数e_s = np.array([0.1, 0.2, 0.3, 0.4])  # 正弦项系数P_min_s = np.array([50, 60, 70, 80])  # 每个发电单元的最小功率输出# 排放系数（根据实际情况修改）alpha_s = np.array([2, 2.5, 3, 3.5])beta_s = np.array([0.1, 0.2, 0.3, 0.4])gamma_s = np.array([0.01, 0.02, 0.03, 0.04])eta_s = np.array([0.5, 0.6, 0.7, 0.8])delta_s = np.array([0.05, 0.06, 0.07, 0.08])# 假设功率调度（P），是一个Ns x M的矩阵，代表每个发电单元在每个时段的功率输出P = np.random.uniform(50, 200, size=(Ns, M))  # 随机生成一些功率调度，单位：MW# 假设电网需求功率（与实际情况一致）power_demand = np.array([900, 1100, 1000, 1300, 1100, 1200])  # 单位：MW，6个时段# 假设水力发电单元的最大功率输出max_hydro_output = np.array([250, 250])  # 单位：MW# 假设热力发电单元的最大功率输出max_thermal_output = np.array([125, 175, 250, 300])  # 单位：MW# 计算总成本目标函数def total_cost(P):    cost = 0    for t in range(M):  # 每个时段        for s in range(Ns):  # 每个发电单元            cost += a_s[s] + b_s[s] * P[s, t] + c_s[s] * P[s, t]**2 + abs(d_s[s] * np.sin(e_s[s] * (P_min_s[s] - P[s, t]))))    return cost# 计算排放目标函数def total_emission(P):    emission = 0    for t in range(M):  # 每个时段        for s in range(Ns):  # 每个发电单元            emission += alpha_s[s] + beta_s[s] * P[s, t] + gamma_s[s] * P[s, t]**2 + eta_s[s] * np.exp(delta_s[s] * P[s, t])    return emission# 粒子群初始化def initialize_particles(population_size, Ns, M,P_min_s,P_max_s):    # 初始化粒子的位置和速度    positions = np.random.uniform(P_min_s[:, np.newaxis], max_thermal_output[:, np.newaxis], size=(population_size, Ns, M))    velocities = np.zeros_like(positions)        # 记录每个粒子的个体最佳位置    pbest_positions = positions.copy()    pbest_values = np.array([total_cost(p) + total_emission(p) for p in positions])        # 记录全局最佳位置    gbest_position = positions[np.argmin(pbest_values)]        return positions, velocities, pbest_positions, pbest_values, gbest_position# 更新速度和位置def update_particles(positions, velocities, pbest_positions, pbest_values, gbest_position, w=0.5, c1=1.5, c2=1.5):    r1 = np.random.random(positions.shape)    r2 = np.random.random(positions.shape)        # 更新速度    velocities = w * velocities + c1 * r1 * (pbest_positions - positions) + c2 * r2 * (gbest_position - positions)        # 更新位置    positions = positions + velocities        # 确保粒子的位置在合法范围内    positions = np.clip(positions, P_min_s[:, np.newaxis], max_thermal_output[:, np.newaxis])        return positions, velocities# 粒子群优化主程序def particle_swarm_optimization(population_size, generations):    positions, velocities, pbest_positions, pbest_values, gbest_position = initialize_particles(population_size, Ns, M)        convergence_curve_cost = []  # 用于记录每代的成本值（收敛曲线）    convergence_curve_emission = []  # 用于记录每代的排放值（收敛曲线）        for generation in tqdm(range(generations), desc=&quot;Generations&quot;, unit=&quot;gen&quot;):        # 计算每个粒子的适应度（成本和排放）        for i in range(population_size):            cost = total_cost(positions[i])            emission = total_emission(positions[i])            fitness_value = cost + emission                        # 更新个体最佳位置            if fitness_value &lt; pbest_values[i]:                pbest_values[i] = fitness_value                pbest_positions[i] = positions[i]                # 更新全局最佳位置        gbest_index = np.argmin(pbest_values)        gbest_position = pbest_positions[gbest_index]                # 更新粒子的速度和位置        positions, velocities = update_particles(positions, velocities, pbest_positions, pbest_values, gbest_position)                # 记录当前代的最优解（成本和排放）        best_cost = total_cost(gbest_position)        best_emission = total_emission(gbest_position)                convergence_curve_cost.append(best_cost)  # 记录成本        convergence_curve_emission.append(best_emission)  # 记录排放        print(f&quot;Generation &#123;generation + 1&#125;: Best Solution (Cost): &#123;best_cost&#125;, Emission: &#123;best_emission&#125;&quot;)        # 绘制收敛曲线    fig, ax1 = plt.subplots()    ax1.set_xlabel(&#x27;Generation&#x27;)    ax1.set_ylabel(&#x27;Cost&#x27;, color=&#x27;tab:blue&#x27;)    ax1.plot(convergence_curve_cost, color=&#x27;tab:blue&#x27;, label=&quot;Cost&quot;)    ax1.tick_params(axis=&#x27;y&#x27;, labelcolor=&#x27;tab:blue&#x27;)    ax2 = ax1.twinx()  # 创建共享X轴的第二个Y轴    ax2.set_ylabel(&#x27;Emission&#x27;, color=&#x27;tab:red&#x27;)    ax2.plot(convergence_curve_emission, color=&#x27;tab:red&#x27;, label=&quot;Emission&quot;)    ax2.tick_params(axis=&#x27;y&#x27;, labelcolor=&#x27;tab:red&#x27;)    fig.tight_layout()  # 调整布局    plt.title(&#x27;Convergence Curve: Cost and Emission&#x27;)    plt.show()# 执行粒子群优化particle_swarm_optimization(population_size=50, generations=100)\r\n\r\n计算得该算法使用时间为1.231s.\r\n普通神经网络\r\n然后可以使用神经网络进行计算，具体代码如下： 损失函数的选择？\r\n\r\n\r\n神经网络\r\n\r\nimport torchimport torch.nn as nnimport torch.optim as optimimport numpy as npimport timeN_s, N_h, M = 5, 5, 10  # 示例值P_s_min = [10] * N_s*MP_s_max = [100] * N_s*MP_h_min = [20] * N_s*MP_h_max = [150] * N_s*MP_D, P_L = 200, 100  # 示例负荷需求a_s = [0.1] * N_s*Mb_s = [0.2] * N_s*Mc_s = [0.3] * N_s*Md_s = [0.4] * N_s*Me_s = [0.5] * N_s*Mβ_s = [0.6] * N_s*Mγ_s = [0.7] * N_s*Mη_s = [0.8] * N_s*Mδ_s = [0.9] * N_s*Mt_T = [1] *  N_s*M  # 假设时间段为1# 1. 定义神经网络模型class MultiObjectiveNN(nn.Module): #定义了一个包含三个全连接层的神经网络    def __init__(self, input_size, output_size):        super(MultiObjectiveNN, self).__init__() # 继承父类的构造函数，初始化神经网络                # 定义神经网络的层        self.fc1 = nn.Linear(input_size, 128) # 输入层到隐藏层        self.fc2 = nn.Linear(128, 64) # 隐藏层到隐藏层        self.fc3 = nn.Linear(64, output_size) # 隐藏层到输出层            def forward(self, x): # 定义前向传播，应用ReLu作为激活函数，最后输出预测值        x = torch.relu(self.fc1(x))  # 激活函数        x = torch.relu(self.fc2(x))        x = self.fc3(x)        return x# 2. 定义目标函数 f1(x) 和 f2(x)def evaluate(individual):    P_s = individual[:N_s * M] #提取前N_s*M个元素    P_h = individual[N_h * M:] #提取后N_h*M个元素        # f1(x) - 热电系统的目标函数    f1 = 0    for t in range(M):        for s in range(N_s):            f1 += t_T[t] * (a_s[s] + b_s[s] * P_s[s * M + t] + c_s[s] * P_s[s * M + t]**2 +                             abs(d_s[s]) * np.sin(e_s[s] * (P_s_min[s] - P_s[s * M + t])))        # f2(x) - 水电系统的目标函数    f2 = 0    for t in range(M):        for s in range(N_h):            f2 += t_T[t] * (a_s[s] + β_s[s] * P_s[s * M + t] + γ_s[s] * P_h[s * M + t]**2 +                             η_s[s] * np.exp(δ_s[s] * P_h[s * M + t]))    return f1, f2# 3. 定义约束条件def check_constraints(individual):    P_s = individual[:N_s * M]    P_h = individual[N_h * M:]    &#x27;&#x27;&#x27;    # 电力平衡约束    power_balance = np.sum(P_s) + np.sum(P_h) - P_D - P_L    # 约束 1: sum(P_s) + sum(P_h) - P_D - P_L = 0    if abs(power_balance) &gt; 1e-6:        print(&quot;不满足约束1&quot;)        return False  # 违反约束    &#x27;&#x27;&#x27;    # 约束 2: P_s_min &lt;= P_s &lt;= P_s_max (热电)    for s in range(N_s):        for t in range(M):            if not (P_s[s * M + t] &gt;= P_s_min[s] and P_s[s * M + t] &lt;= P_s_max[s]):                print(&quot;不满足约束2&quot;)                return False  # 违反约束        # 约束 3: P_h_min &lt;= P_h &lt;= P_h_max (水电)    for h in range(N_h):        for t in range(M):            if not (P_h[h * M + t] &gt;= P_h_min[h] and P_h[h * M + t] &lt;= P_h_max[h]):                print(&quot;不满足约束3&quot;)                return False  # 违反约束    return True# 4. 构建训练数据集def generate_training_data(num_samples):    X_data = []    y_data = []    valid_samples = 0    for _ in range(num_samples):        # 随机生成输入数据        P_s = np.random.uniform(P_s_min, P_s_max, N_s * M)         P_h = np.random.uniform(P_h_min, P_h_max, N_h * M)                individual = np.concatenate([P_s,P_h]) # 将两个数组连接起来        #print(individual)        # 如果满足约束，计算目标函数        if check_constraints(individual):            valid_samples += 1            f1, f2 = evaluate(individual)            X_data.append(individual)            y_data.append([f1, f2])  # 两个目标函数的值        if not check_constraints(individual):            continue    print(f&quot;Generated &#123;valid_samples&#125; valid samples out of &#123;num_samples&#125;&quot;)    return np.array(X_data), np.array(y_data)    # 5. 定义损失函数def loss_function(predictions, targets, constraints):    # 目标函数损失：最小化 f1 和 f2    loss = torch.mean(torch.sum(predictions ** 2, dim=1))  # 对每个目标函数计算平方损失        # 约束损失：如果违反约束，则增加惩罚    if not constraints:        loss += 1000  # 如果违反约束，加大惩罚        return loss# 6. 训练神经网络模型def train_model(model, X_train, y_train, epochs=10, lr=0.001):    optimizer = optim.Adam(model.parameters(), lr=lr)    criterion = loss_function        for epoch in range(epochs):        model.train()        print(len(X_train))        for i in range(len(X_train)):                        X_batch = torch.tensor(X_train[i:i+1], dtype=torch.float32)            y_batch = torch.tensor(y_train[i:i+1], dtype=torch.float32)                        optimizer.zero_grad()                        predictions = model(X_batch) # 预测目标函数值                        # 检查约束            constraints = check_constraints(X_train[i])                        # 计算损失            loss = criterion(predictions, y_batch, constraints)                        # 反向传播和优化            loss.backward()             optimizer.step()                print(f&quot;Epoch &#123;epoch+1&#125;/&#123;epochs&#125;, Loss: &#123;loss.item()&#125;&quot;)# 7. 运行并优化模型def main():    start_time = time.time()    # 构建训练数据    X_train, y_train = generate_training_data(1000)  # 1000个样本    if X_train.size == 0 or y_train.size == 0:        print(&quot;No valid training data generated.&quot;)        return        # 初始化神经网络模型    model = MultiObjectiveNN(input_size=N_s * M + N_h * M, output_size=2)        # 训练模型    train_model(model, X_train, y_train, epochs=10, lr=0.001)        # 使用训练好的模型进行预测    input_test = torch.randn(1, N_s * M + N_h * M)  # 随机生成一个测试输入    output_test = model(input_test)    print(f&quot;Predicted output (cost and emission): &#123;output_test&#125;&quot;)        end_time = time.time()  # 结束计时    elapsed_time = end_time - start_time  # 计算经过的时间    print(f&quot;Evaluation time: &#123;elapsed_time&#125; seconds&quot;)  # 打印计算时间if __name__ == &quot;__main__&quot;:    main()\r\n在同等规模下，神经网络算法需要用时23.81s。\r\n由PSO改进的神经网络\r\n尝试将PSO算法和神经网络结合起来，求解该问题。具体代码如下:\r\n\r\n\r\nPSO结合神经网络\r\n\r\nimport torchimport torch.nn as nnimport torch.optim as optimimport numpy as npimport time# 1. 定义神经网络模型class MultiObjectiveNN(nn.Module):    def __init__(self, input_size, output_size):        super(MultiObjectiveNN, self).__init__()        # 定义神经网络的层        self.fc1 = nn.Linear(input_size, 128)        self.fc2 = nn.Linear(128, 64)        self.fc3 = nn.Linear(64, output_size)    def forward(self, x):        x = torch.relu(self.fc1(x))  # 激活函数        x = torch.relu(self.fc2(x))        x = self.fc3(x)        return x# 2. 定义问题的参数和目标函数N_s, N_h, M = 5, 5, 10  # 示例值P_s_min = [10] * (N_s*M+N_h*M)P_s_max = [100] * (N_s*M+N_h*M)P_h_min = [10] * (N_s*M+N_h*M)P_h_max = [150] * (N_s*M+N_h*M)P_D, P_L = 200, 100  # 示例负荷需求a_s = [0.1] * (N_s*M+N_h*M)b_s = [0.2] * (N_s*M+N_h*M)c_s = [0.3] * (N_s*M+N_h*M)d_s = [0.4] * (N_s*M+N_h*M)e_s = [0.5] * (N_s*M+N_h*M)β_s = [0.6] * (N_s*M+N_h*M)γ_s = [0.7] * (N_s*M+N_h*M)η_s = [0.8] * (N_s*M+N_h*M)δ_s = [0.9] * (N_s*M+N_h*M)t_T = [1] * (N_s*M+N_h*M)  # 假设时间段为1# 3. 定义目标函数 f1(x) 和 f2(x)def evaluate(position):    P_s = position[:N_s * M]    P_h = position[N_s * M:]        # f1(x) - 热电系统的目标函数    f1 = 0    for t in range(M):        for s in range(N_s):            f1 += t_T[t] * (a_s[s] + b_s[s] * P_s[s * M + t] + c_s[s] * P_s[s * M + t]**2 +                             abs(d_s[s]) * np.sin(e_s[s] * (P_s_min[s] - P_s[s * M + t])))        # f2(x) - 水电系统的目标函数    f2 = 0    for t in range(M):        for s in range(N_s):            f2 += t_T[t] * (a_s[s] + β_s[s] * P_s[s * M + t] + γ_s[s] * P_s[s * M + t]**2 +                             η_s[s] * np.exp(δ_s[s] * P_s[s * M + t]))    return f1, f2# 4. 定义约束条件def check_constraints(position):    P_s = position[:N_s * M]    P_h = position[N_s * M:]    &#x27;&#x27;&#x27;    # 电力平衡约束    power_balance = np.sum(P_s) + np.sum(P_h) - P_D - P_L        # 约束 1: sum(P_s) + sum(P_h) - P_D - P_L = 0    if abs(power_balance) &gt; 1e-6:        return False  # 违反约束    &#x27;&#x27;&#x27;    # 约束 2: P_s_min &lt;= P_s &lt;= P_s_max (热电)    for s in range(N_s):        for t in range(M):            if not (P_s[s * M + t] &gt;= P_s_min[s] and P_s[s * M + t] &lt;= P_s_max[s]):                return False  # 违反约束        # 约束 3: P_h_min &lt;= P_h &lt;= P_h_max (水电)    for h in range(N_h):        for t in range(M):            if not (P_h[h * M + t] &gt;= P_h_min[h] and P_h[h * M + t] &lt;= P_h_max[h]):                return False  # 违反约束    return True  # 如果没有违反任何约束，则返回 True# 5. 粒子群优化（PSO）算法实现class PSO:    def __init__(self, n_particles, n_iterations, input_size, model):        self.n_particles = n_particles        self.n_iterations = n_iterations        self.position = np.random.uniform(P_s_min,P_s_max,size=(n_particles, N_s * M + N_h * M))  # 初始化粒子位置        self.velocity = np.random.uniform(P_h_min,P_h_max,size=(n_particles, N_s * M + N_h * M))  # 初始化粒子速度        self.pbest_position = np.copy(self.position)  # 个体最优位置        self.pbest_value = np.full(self.n_particles, np.inf)  # 个体最优适应度        self.gbest_position = np.zeros(input_size)  # 全局最优位置        self.gbest_value = np.inf  # 全局最优适应度                # 速度更新的常数        self.w = 0.5  # 惯性权重        self.c1 = 1.5  # 自我认知因子        self.c2 = 1.5  # 社会认知因子                self.model = model  # 神经网络模型        self.optimizer = optim.Adam(self.model.parameters(), lr=0.001)        self.criterion = nn.MSELoss()    def update_velocity(self, particle_idx):        r1 = np.random.random(N_s * M + N_h * M)        r2 = np.random.random(N_s * M + N_h * M)        inertia = self.w * self.velocity[particle_idx]        cognitive = self.c1 * r1 * (self.pbest_position[particle_idx] - self.position[particle_idx])        social = self.c2 * r2 * (self.gbest_position - self.position[particle_idx])        self.velocity[particle_idx] = inertia + cognitive + social    def update_position(self, particle_idx):        self.position[particle_idx] = self.position[particle_idx] + self.velocity[particle_idx]        # 限制粒子的位置在约束范围内        self.position[particle_idx] = np.clip(self.position[particle_idx], P_s_min,P_s_max)    def optimize(self):        for _ in range(self.n_iterations):            for i in range(self.n_particles):                fitness = evaluate(self.position[i])                if check_constraints(self.position[i]):                    if fitness[0] &lt; self.pbest_value[i]:  # 更新个体最优                        self.pbest_value[i] = fitness[0]                        self.pbest_position[i] = self.position[i]                    if fitness[0] &lt; self.gbest_value:  # 更新全局最优                        self.gbest_value = fitness[0]                        self.gbest_position = self.position[i]                        # 用全局最优解训练神经网络            inputs = torch.tensor(self.gbest_position, dtype=torch.float32).unsqueeze(0)  # 输入            targets = torch.tensor([self.gbest_value], dtype=torch.float32).unsqueeze(0)  # 目标                        # 训练神经网络            self.optimizer.zero_grad()            predictions = self.model(inputs)            loss = self.criterion(predictions, targets)            loss.backward()            self.optimizer.step()            # 更新速度和位置            for i in range(self.n_particles):                self.update_velocity(i)                self.update_position(i)# 6. 运行 PSO 和神经网络优化def main():    start_time = time.time()    input_size = N_s * M + N_h * M    model = MultiObjectiveNN(input_size, output_size=2)  # 初始化神经网络模型    pso = PSO(n_particles=50, n_iterations=100, input_size=input_size, model=model)  # 30个粒子，100代迭代    pso.optimize()# 输出最优解    print(f&quot;Global Best Position (Optimal Solution): &#123;pso.gbest_position&#125;&quot;)    print(f&quot;Global Best Value (Optimal Objective Value): &#123;pso.gbest_value&#125;&quot;)    &#x27;&#x27;&#x27;    print(f&quot;Global Best Position: &#123;pso.gbest_position&#125;&quot;)    print(f&quot;Global Best Value: &#123;pso.gbest_value&#125;&quot;)    &#x27;&#x27;&#x27;      end_time = time.time()    elapsed_time = end_time - start_time    print(f&quot;程序运行时间：&#123;elapsed_time:.2f&#125;秒&quot;)if __name__ == &quot;__main__&quot;:    main()\r\n计算时间为3.01s。\r\n由以上可得，遗传算法、粒子群算法、神经网络都可以用于求解动态优化问题\r\n","tags":["论文"]},{"title":"NumPy+Pandas+Matplotlib学习","url":"/2024/12/29/NumPy-Pandas-Matplotlib%E5%AD%A6%E4%B9%A0/","content":"NumPy基础\r\nNumPy几个重要定义\r\n\r\naxis:维度\r\nrank:维度数\r\nshape:各维度的元素数\r\nsize:数组内所有元素的数量\r\n\r\n创建数组\r\n1、创建一个自定义大小和内容的数组 np_array = np.array([[1,2,3,4],[5,6,7,8]])\r\n2、创建一个全为0的1*5的数组 zero_array = np.zeros((5))\r\n3、创建一个全为1的4*4的数组 one_array = np.ones((4,4))\r\n4、创建全为一个数的3*3数组 full_array = np.full((3,3),7)\r\n5、创建一个空的2*3数组，数组值来自内存任意数 empty_array = np.empty((2,3))\r\n6、改变输出数组的形状 x = np.array([[1,2,3],[4,5,6]])y = np.reshape(x,(3,2))\r\n7、将数组读取改为一维 z = y.rival()\r\n注意，以上两种方法只是改变了数组的输出方式，并没有复制成为新的数组，如果改变y、z的内容，x内容也会相应改变。\r\n8、复制数组到新的数组 array3 = array1.copy()\r\n9、生成(0,1)随机数 random_array = np.random.random((5,5))\r\n10、生成整数随机数 rand1 = np.random.randint(100,size=(5,2))\r\n11、生成服从正态分布的随机数 rand3 = np.random.randn(100)\r\n12、生成4维单位矩阵 eye_array = np.eye(4)\r\n13、生成1-5的等差数列 array = np.arange(1,5)\r\n14、生成规定步长的等差数列 array = np.arange(1,5,0.5)\r\n15、平均分(0,5)区间 array = np.linspace(0,5,10)\r\n16、自定义函数处理数组 def my_function(z,y,x):    return x*y+zarray = np.fromfunction(my_function,(3,2,10))\r\n索引\r\n1、二维数组索引 matrix1 = np.array([[1,2,3],[4,5,6],[7,8,9]])print(matrix1)print(matrix1[0,2])matrix1[0,1] = 100print(matrix1)print(matrix1[[0,2,2],[0,1,0]])print(matrix1[(0,2),2:5])\r\n2、高维数组索引 matrix_3d = np.arange(80).reshape(4,5,4)print(matrix_3d)print(matrix_3d[2,...])print(matrix_3d[0,2,...])print(matrix_3d[3,...,2])print(matrix_3d[3,:,2])\r\n3、布尔索引 matrix3 = np.array([[1,2],[3,4],[5,6]])print(matrix3)bool_idx = (matrix3 &gt; 2)print(bool_idx)print(matrix3[bool_idx])print(matrix3%2 == 1)matrix4 = np.arange(36).reshape(3,12)rows_on = [True, False, True]cols_on = [True, False, True, False, True, False, True, False, True, False, True, False]print(matrix4[np.ix_(rows_on,cols_on)])\r\n4、提取数组元素 two_dimensional_list = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])for item in two_dimensional_list:    print(item)for row in two_dimensional_list:   print(row)for column in two_dimensional_list.T:    print(column)three_dimentiional_list = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]])for item in three_dimentiional_list.flat:    print(item)for item in three_dimentiional_list:    print(item)\r\n数学函数、统计、线性代数\r\n1、Arithmetic operations:+ - * / // % **\r\nmatrix1 = np.array([[1, 2, 3], [4, 5, 6]])matrix2 = np.array([[4, 5, 6], [7, 8, 9]])print(np.add(matrix1, matrix2)) # 求和print(np.subtract(matrix1, matrix2)) # 求差print(np.multiply(matrix1, matrix2)) # 求积print(np.floor_divide(matrix1, matrix2)) # 除print(np.power(matrix1, matrix2)) # 乘方print(np.mod(matrix1, matrix2)) # 取余\r\n2、function\r\nrand_matrix = np.array([[20,15.4,-12.8,-1.1,-8.8],[-18.3,-19.6,20.2,-15.5,43.1]])print(np.isnan(rand_matrix)) # 判断是否为nanprint(np.sign(rand_matrix)) # 判断正负print(np.nonzero(rand_matrix)) # 判断是否为0print(np.ceil(rand_matrix)) # 向上取整print(np.cumsum(rand_matrix)) # 累加print(np.diff(rand_matrix)) # 累差print(np.sqrt(rand_matrix)) # 开方print(np.square(rand_matrix)) # 平方print(np.sin(rand_matrix)) # 正弦print(np.sort(rand_matrix)) # 排序\r\n3、统计\r\nmatrix = np.arange(-5,5).reshape(2,5)print(matrix.mean()) # 求平均值print(np.median(matrix)) # 求中位数print(np.argmax(matrix)) # 求最大值的索引print(np.argmin(matrix)) # 求最小值的索引print(np.sum(matrix)) # 求和print(np.abs(matrix)) # 求绝对值print(np.max(matrix)) # 求最大值print(np.sum(matrix,axis=0)) # 求每一列的和print(np.sum(matrix,axis=1)) # 求每一行的和\r\n4、线性代数\r\nmatrix1 = np.arange(16).reshape(4,4)matrix2 = np.arange(8).reshape(2,4)print(matrix1.T) # 转置print(matrix1.dot(matrix2.T)) # 矩阵乘法print(np.linalg.inv(matrix1)) # 逆矩阵print(np.linalg.det(matrix1)) # 行列式eigenvalues, eigenvectors = np.linalg.eig(matrix1) # 特征值和特征向量print(eigenvalues)print(eigenvectors)\r\n5、求解线性方程\r\ncoeffs = np.array([[2,6],[5,3]]) # 系数矩阵depvars = np.array([6,-9]) # 常数项solution = np.linalg.solve(coeffs,depvars) # 解方程print(solution)\r\n合并、分割、广播\r\n1、交换维度 m1 = np.ones((1,2,3))print(np.transpose(m1,(1,0,2))) # 交换维度m2 = np.ones((2,3,4,5))print(np.transpose(m2)) # 交换维度m3 = m2.swapaxes(1,2) # 交换维度\r\n2、合并 array1 = np.full((1,5),1.0)array2 = np.full((1,5),2.0)stake_array = np.vstack((array1,array2)) # 垂直堆叠数组print(stake_array)stake_array = np.hstack((array1,array2)) # 水平堆叠数组print(stake_array)stake_array = np.concatenate((array1,array2),axis=0) # 按行堆叠数组（同vstack）print(stake_array)stake_array = np.concatenate((array1,array2),axis=1) # 按列堆叠数组（同hstack）print(stake_array)stake_array = np.stack((array1,array2)) #沿新轴合并数组，保持两矩阵形状相同print(stake_array)\r\n3、分割 big_matrix = np.arange(36).reshape(9,4)m1,m2,m3 = np.vsplit(big_matrix,3) # 垂直分割(按行分割)m4,m5 = np.hsplit(big_matrix,2) # 水平分割(按列分割)m1 = np.arange(4)m2 = np.tile(m1,(4,1)) #第一个维度重复4次，第二个维度重复1次\r\n4、广播\r\n广播的前提：两个数组必须可以转化成维度大小一样的数组才能进行计算 -\r\n规则1、如果两个数组维度不同，那么小维度数组的形状将在最左边补1 -\r\n规则2、如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为1的维度扩展，匹配另一个数组的形状\r\n-\r\n规则3、如果两个数组在任何一个维度上都不匹配且没有一个维度为1，则发生异常\r\nm2 = np.arange(6).reshape(2,3)print(m2+[[10],[20]])  # 扩展为[[10,10,10],[20,20,20]]print(m2+[10,20,30]) # 扩展为[[10,20,30],[10,20,30]]print(m2+10) #扩展为[[10,10,10],[10,10,10]]m3 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])m4 = np.array([1,0,1])print(m3+m4) # 扩展为4行3列，然后相加\r\nPandas基础\r\nSeries和DataFrame\r\n1、Seires random_items = np.random.randint(25,size=10)    # 生成10个0-25之间的随机数series_data = pd.Series(random_items)   # 将随机数转换为Series对象print(series_data[0])   # 输出第一个元素letter_index = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;]    # 生成索引new_series = pd.Series(random_items,index=letter_index)  # 将随机数转换为Series对象，并指定索引print(new_series)   # 输出Series对象data_dict = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3,&#x27;d&#x27;:4,&#x27;e&#x27;:5&#125;    # 生成字典dict_series = pd.Series(data_dict)   # 将字典转换为Series对象print(dict_series)   # 输出Series对象dict_series = pd.Series(data_dict,name = &#x27;series_name&#x27;)   # 将字典转换为Series对象，并指定名称print(dict_series)   # 输出Series对象dict_series = dict_series.rename(&#x27;new_name&#x27;)   # 重命名Series对象print(dict_series)   # 输出Series对象print(dict_series.median())   # 输出Series对象的中位数print(dict_series&gt;dict_series.median())   # 输出Series对象中大于中位数的元素\r\n2、DataFram d = &#123;&#x27;one&#x27;:[1,2,3,4]     ,&#x27;two&#x27;:[4,3,2,1]&#125;  # 创建一个字典dict_df = pd.DataFrame(d)  # 将字典转换为数据框print(dict_df)print(dict_df[&#x27;one&#x27;])  # 输出one列print(dict_df.shape)  # 输出数据框的行数和列数d_data = &#123;    &#x27;one&#x27;:pd.Series([1,2,3,],name = &#x27;col_one&#x27;,index = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]),    &#x27;two&#x27;:pd.Series([1,2,3,4],name = &#x27;col_two&#x27;,index = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;])&#125;df = pd.DataFrame(d_data)print(df)new_df = df.reset_index(drop = True)    # drop = True 丢弃原来的索引print(new_df)print(df)df.reset_index(drop = True,inplace = True)   # drop = True 丢弃原来的索引df.reset_index(drop = False,inplace = True) # drop = False 保留原来的索引 3、大型表格索引 country_info= pd.read_csv(&#x27;D:\\Downloads\\country.csv&#x27;)print(country_info.columns) # 查看列名print(country_info.head(3)) # 查看前3行print(country_info.head())  # 查看前5行print(country_info.tail())  # 查看后5行print(country_info[&#x27;Region&#x27;]) # 查看Region列print(country_info[[&#x27;Region&#x27;,&#x27;Country&#x27;]]) # 查看Region和Country列print(country_info.iloc[100]) # 查看行print(country_info.iloc[[2,3]]) # 查看多行print(country_info.iloc[[2,3],[0,3]]) # 查看多行多列country_info[&#x27;Country&#x27;] = country_info[&#x27;Country&#x27;].str.strip() # 去除头和尾的空格country_info.set_index([&#x27;Country&#x27;],drop=True,inplace=True) # 设置Country为索引print(country_info.loc[&#x27;China&#x27;]) # 查看China行print(country_info.loc[[&#x27;China&#x27;,&#x27;India&#x27;]]) # 查看China和India行print(country_info.loc[[&#x27;China&#x27;,&#x27;India&#x27;],[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 查看China和India行的Region和Population列print(country_info.loc[&#x27;China&#x27;:&#x27;India&#x27;,&#x27;Region&#x27;:&#x27;Deathrate&#x27;]) # 查看China到India行\r\n\r\nHOMEWORK\r\n\r\n使用read_csv获取country数据，读取前十行的数据，只选取Country、Birthrate和Service，将其中的数据变成DataFrame,并使用to_csv函数将结果存到本地的country.csv文件中。\r\ncountry_info= pd.read_csv(&#x27;D:\\Downloads\\country.csv&#x27;)print(country_info.head(10))    #查看前10行数据print(country_info[[&#x27;Country&#x27;,&#x27;Birthrate&#x27;,&#x27;Service&#x27;]])  #提取数据df_country = pd.DataFrame(country_info[[&#x27;Country&#x27;,&#x27;Birthrate&#x27;,&#x27;Service&#x27;]])  #提取数据print(df_country)df_country.to_csv(&#x27;D:\\Downloads\\country.csv&#x27;,index=False) #保存数据但不保存索引\r\nFiltering\r\ncountry_info= pd.read_csv(&quot;D:\\Downloads\\country.csv&quot;)print(country_info[&#x27;Net migration&#x27;] ==&#x27;0&#x27;)  # 选出净移民为0的国家zero_migration_filter = (country_info[&#x27;Net migration&#x27;] ==&#x27;0&#x27;) # 选出净移民为0的国家print(country_info[zero_migration_filter]) # 输出净移民为0的国家print(country_info.loc[zero_migration_filter,[&#x27;Region&#x27;,&#x27;Country&#x27;,&#x27;Net migration&#x27;]]) # 输出净移民为0的国家的地区、国家名和净移民数low_migration_filter = (country_info[&#x27;Net migration&#x27;] &lt;&#x27;100&#x27;) # 选出净移民小于100的国家print(country_info.loc[low_migration_filter,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出净移民小于100的国家的地区和人口数and_filter = (country_info[&#x27;Deathrate&#x27;]&gt;&#x27;1000&#x27;)&amp;(country_info[&#x27;Population&#x27;]&lt;10000) # 选出死亡率大于1000且人口小于10000的国家print(country_info.loc[and_filter,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出死亡率大于1000且人口小于10000的国家的地区和人口数or_filter = (country_info[&#x27;Deathrate&#x27;]&gt;&#x27;1000&#x27;)|(country_info[&#x27;Population&#x27;]&lt;10000) # 选出死亡率大于1000或人口小于10000的国家print(country_info.loc[or_filter,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出死亡率大于1000或人口小于10000的国家的地区和人口数population_filter = (country_info[&#x27;Population&#x27;]&gt;100000) # 选出人口大于100000的国家print(country_info.loc[~population_filter,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出人口不大于100000的国家的地区和人口数countries = [&#x27;China&#x27;,&#x27;Japan&#x27;,&#x27;United States&#x27;,&#x27;Russia&#x27;,&#x27;India&#x27;] # 选出中国、日本、美国、俄罗斯和印度的数据infilter = country_info[&#x27;Country&#x27;].isin(countries) # 选出中国、日本、美国、俄罗斯和印度的数据print(country_info.loc[infilter,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出中国、日本、美国、俄罗斯和印度的地区和人口数str_filter = country_info[&#x27;Country&#x27;].str.contains(&quot;A&quot;) # 选出国家名中包含字母“A”的国家print(country_info.loc[~str_filter,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出国家名中不包含字母“A”的国家的地区和人口数str_filter2 = country_info[&#x27;Country&#x27;].str.contains(&quot;A|Z&quot;) # 选出国家名中包含字母“A”或“Z”的国家print(country_info.loc[str_filter2,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出国家名中包含字母“A”或“Z”的国家的地区和人口数str_filter3 = country_info[&#x27;Country&#x27;].str.contains(&quot;[a-m]&quot;) # 选出国家名中包含字母“A”到“M”的国家print(country_info.loc[str_filter3,[&#x27;Region&#x27;,&#x27;Population&#x27;]]) # 输出国家名中包含字母“A”到“M”的国家的地区和人口数\r\n排序和增删查改\r\n1、排序搜索 survey_df = pd.read_csv(&quot;D:\\Downloads\\small_survey_results.csv&quot;)survey_df.set_index(&#x27;Respondent&#x27;, inplace=True) # 将Respondent列设置为索引列print(survey_df.sort_index()) # 按照索引列排序print(survey_df.sort_values(by=&#x27;Age&#x27;,ascending = False)) # 按照Age列排序print(survey_df.sort_values(by=[&#x27;Age&#x27;,&#x27;YearsCode&#x27;],ascending = [False,True])[[&#x27;Age&#x27;,&#x27;YearsCode&#x27;]]) # 按照Age列排序，如果Age相同，按照YearsCode列排序print(survey_df.sort_values(by=[&#x27;Age&#x27;,&#x27;YearsCode&#x27;],ascending = [0,1])[[&#x27;Age&#x27;,&#x27;YearsCode&#x27;]]) # 按照Age列排序，如果Age相同，按照YearsCode列排序，显示前10行print(survey_df[&#x27;Age&#x27;].sort_values())print(survey_df[&#x27;ConvertedComp&#x27;].nlargest(10)) # 找出ConvertedComp列中最大的10个值print(survey_df[&#x27;ConvertedComp&#x27;].nsmallest(10)) # 找出ConvertedComp列中最小的10个值richest_users = survey_df.nlargest(10,&#x27;ConvertedComp&#x27;) # 找出ConvertedComp列中最大的10个值，并显示所有列print(richest_users[[&#x27;ConvertedComp&#x27;,&#x27;DevType&#x27;,&#x27;EdLevel&#x27;]]) # 找出ConvertedComp列中最大的10个值，并显示ConvertedComp和DevType列\r\n2、增删改查\r\nsurvey_df = pd.read_csv(&quot;D:\\Downloads\\small_survey_results.csv&quot;)for col_name,col_data in survey_df.items(): # 遍历所有列    print(col_name)    print(col_data)    breakfor row_index,row_data in survey_df.iterrows(): # 遍历所有行    print(row_index)    print(row_data)    breakinversed_df = pd.DataFrame(&#123;idx:values for idx,values in survey_df.items()&#125;) # 转置print(inversed_df.shape)survey_df.rename(columns = &#123;&#x27;Age&#x27;:&#x27;user age&#x27;,&#x27;Orgsize&#x27;:&#x27;organization size&#x27;&#125;,inplace=True) # 重命名列print(survey_df.columns)survey_df.columns = survey_df.columns.str.replace(&#x27; &#x27;,&#x27;_&#x27;) # 替换列名中的空格print(survey_df.columns)survey_df.columns = [col.lower() for col in survey_df.columns] # 将列名转换为小写print(survey_df.columns)print(survey_df[&#x27;jobfactors&#x27;].str.lower()) # 将列中的字符串转换为小写survey_df.loc[2,&#x27;trans&#x27;] = &#x27;Yes&#x27; # 修改指定位置的值print(survey_df.loc[2])survey_df.loc[2,[&#x27;trans&#x27;,&#x27;user_age&#x27;,&#x27;country&#x27;]] = [&#x27;Yes&#x27;,29,&#x27;China&#x27;] # 修改指定位置的值print(survey_df.loc[2])survey_df.loc[survey_df[&#x27;user_age&#x27;]&lt;18,[&#x27;age_group&#x27;]] = &#x27;young&#x27; # 根据条件修改值print(survey_df.loc[survey_df[&#x27;user_age&#x27;]&lt;18])survey_df.loc[survey_df[&#x27;user_age&#x27;]&gt;=18,[&#x27;age_group&#x27;]] = &#x27;adult&#x27; # 根据条件修改值print(survey_df.loc[survey_df[&#x27;user_age&#x27;]&gt;=18])survey_df[&#x27;gen_col&#x27;]=survey_df[&#x27;gender&#x27;]+survey_df[&#x27;sexuality&#x27;]+survey_df[&#x27;trans&#x27;] # 新增列print(survey_df[&#x27;gen_col&#x27;])survey_df[&#x27;job_factors&#x27;]=survey_df[&#x27;jobfactors&#x27;].str.split(&#x27;;&#x27;)print(survey_df[&#x27;job_factors&#x27;])survey_df[[&#x27;job-fac1&#x27;,&#x27;job-fac2&#x27;,&#x27;job-fac3&#x27;]] = survey_df[&#x27;jobfactors&#x27;].str.split(&#x27;;&#x27;,expand=True) # 将列中的字符串按指定字符分割print(survey_df[[&#x27;job-fac1&#x27;,&#x27;job-fac2&#x27;,&#x27;job-fac3&#x27;]]) # 将列中的字符串按指定字符分割survey_df._append(&#123;&#x27;user_age&#x27;:30,&#x27;country&#x27;:&#x27;China&#x27;&#125;,ignore_index=True) # 添加行print(survey_df)new_survey=&#123;&#x27;user_age&#x27;:25,&#x27;country&#x27;:&#x27;China&#x27;,&#x27;age1stcode&#x27;:24&#125;new_survey_df = pd.DataFrame(new_survey,index=[0])print(survey_df._append(new_survey_df,ignore_index=True,sort=False)) # 添加行print(survey_df.drop(columns=[&#x27;soaccount&#x27;],inplace=True))# 删除列print(survey_df.drop(index=4))# 删除行age_filter = survey_df[&#x27;user_age&#x27;]&lt;50print(survey_df.drop(index=survey_df[age_filter].index))# 删除指定条件行\r\n3、apply,map,applymap,replace\r\nsurvey_df = pd.read_csv(&quot;D:\\Downloads\\small_survey_results.csv&quot;)dtypes = survey_df.dtypes # 获取数据类型str_cols=[col_name for col_name in dtypes.index if dtypes[col_name]==&#x27;object&#x27;] # 获取字符串类型的列名survey_df[str_cols]=survey_df[str_cols].astype(str) # 将字符串类型的列转换为字符串类型print(survey_df[&#x27;Hobbyist&#x27;].apply(len))def upper_case(col_value):    return col_value.upper()print(survey_df[&#x27;Hobbyist&#x27;].apply(upper_case)) # 将hobbyist列的值转换为大写survey_df[&#x27;Hobbyist&#x27;] = survey_df[&#x27;Hobbyist&#x27;].apply(lambda x: x.upper()) # 将hobbyist列的值转换为大写print(survey_df[&#x27;Hobbyist&#x27;])print(survey_df.apply(len,axis=&#x27;columns&#x27;)) # 计算每行的长度print(survey_df.apply(lambda x:x.min())) # 计算每列的最小值map_dict = &#123;&#x27;YES&#x27;:True,&#x27;NO&#x27;:False&#125;print(survey_df[&#x27;Hobbyist&#x27;].map(map_dict)) # 将hobbyist列的值转换为布尔值print(survey_df[str_cols].applymap(len)) # 计算字符串列的长度map_dict=&#123;&#x27;YES&#x27;:True&#125;print(survey_df[&#x27;Hobbyist&#x27;].replace(map_dict)) # 将hobbyist列的值转换为布尔值\r\n聚合、分组、数据清理\r\n1、聚合、分组\r\nsurvey_df = pd.read_csv(&quot;D:\\Downloads\\small_survey_results.csv&quot;)print(survey_df[&#x27;ConvertedComp&#x27;].median()) # 显示数据的中位数print(survey_df[&#x27;ConvertedComp&#x27;].describe()) # 显示数据的统计信息print(survey_df[&#x27;Hobbyist&#x27;].value_counts(normalize=True)) # normalize=True表示显示百分比country_groups=survey_df.groupby([&#x27;Country&#x27;]) # 按国家分组print(country_groups.get_group(&#x27;India&#x27;)) # 获取印度的数据print(survey_df.groupby([&#x27;Country&#x27;]).count()) # 统计各个国家的数据量print(survey_df.groupby([&#x27;Country&#x27;]).get_group(&#x27;China&#x27;)[&#x27;OpSys&#x27;].value_counts()) # 获取中国的数据，并统计操作系统的数量print(country_groups[&#x27;OpSys&#x27;].value_counts().loc[&#x27;China&#x27;]) # 获取中国的数据，并统计操作系统的数量print(country_groups[&#x27;ConvertedComp&#x27;].median().loc[&#x27;Germany&#x27;]) # 获取德国的数据，并统计薪资的中位数print(country_groups[&#x27;ConvertedComp&#x27;].agg([&#x27;median&#x27;,&#x27;mean&#x27;])) # 统计薪资的中位数和平均数country_filter = survey_df[&#x27;Country&#x27;] == &#x27;United States&#x27; # 筛选出美国的数据print(survey_df.loc[country_filter][&#x27;LanguageWorkedWith&#x27;].str.contains(&#x27;Python&#x27;).sum()) # 统计美国使用Python的人数country_groups = survey_df.groupby([&#x27;Country&#x27;]).sum() # 按国家分组，并求和print(country_groups) # 显示各个国家的数据和country_groups = survey_df.groupby(&#x27;Country&#x27;)country_users_python = country_groups[&#x27;LanguageWorkedWith&#x27;].apply(lambda x:x.str.contains(&#x27;Python&#x27;).sum())country_respondents = survey_df[&#x27;Country&#x27;].value_counts()concated_df = pd.concat([country_respondents, country_users_python], axis=&#x27;columns&#x27;, sort=False) # 合并两个Seriesconcated_df.rename(columns=&#123;&#x27;Country&#x27;:&#x27;NumIfUsers&#x27;, &#x27;LanguageWorkedWith&#x27;:&#x27;NumOfPythonUsers&#x27;&#125;, inplace=True) # 重命名列名print(concated_df)\r\n2、数据清理 survey_df = pd.read_csv(&quot;D:\\Downloads\\small_survey_results.csv&quot;)print(small_survey_df.dropna()) # 删除缺失值print(small_survey_df.dropna(axis=&#x27;index&#x27;,how=&#x27;all&#x27;)) # 删除全为缺失值的行print(small_survey_df.dropna(axis=&#x27;index&#x27;,how=&#x27;all&#x27;,subset=[&#x27;CompFreq&#x27;,&#x27;CompTotal&#x27;])) # 删除CompFreq和CompTotal列全为缺失值的行small_survey_df.replace(&#x27;No&#x27;,np.nan,inplace=True) # 将No替换为缺失值print(small_survey_df.isna()) # 查看缺失值print(small_survey_df.fillna(&#x27;Missing&#x27;)) # 填充缺失值为missingsurvey_df[&#x27;YearsCode&#x27;].replace(&#x27;Less than 1 year&#x27;,0,inplace=True)# 将Less than 1 year替换为0print(survey_df)survey_df[&#x27;YearsCode&#x27;] = survey_df[&#x27;YearsCode&#x27;].astype(float) # 将YearsCode转换为浮点型print(survey_df[&#x27;YearsCode&#x27;].mean()) # 计算YearsCode的均值\r\n3、实际应用\r\nframework_df = survey_df[&#x27;WebframeWorkedWith&#x27;].str.split(&#x27;;&#x27;, expand=True) # 拆分数据framework_df.fillna(&#x27;None&#x27;, inplace=True) # 将空值填充为Nonecountry_groups = survey_df.groupby([&#x27;Country&#x27;] )# 按国家分组district_frameworks = np.unique(framework_df.values) # 获取所有的框架framework_sum_array = []    # 创建一个空数组for framework in district_frameworks:    new_df = country_groups[&#x27;WebframeWorkedWith&#x27;].apply(lambda x: x.str.contains(framework).sum()) # 计算每个国家的框架数量    new_df.name = framework    framework_sum_array.append(new_df)user_count = survey_df[&#x27;Country&#x27;].value_counts() # 计算每个国家的用户数量concated_df = pd.concat([user_count]+framework_sum_array, axis=&#x27;columns&#x27;) # 拼接数据print(concated_df)most_popular_df = concated_df.drop(columns = [&#x27;Country&#x27;,&#x27;None&#x27;]).idxmax(axis=1) # 获取每个国家最流行的框架most_popular_df.name = &#x27;most_popular_framework&#x27;final_df = concated_df.join(most_popular_df)[[&#x27;Country&#x27;,&#x27;most_popular_framwork&#x27;]] # 拼接数据\r\n横向合并和纵向合并\r\nmovies = pd.DataFrame(&#123;&#x27;movie_id&#x27;:[1,2,3,5,7],                       &#x27;title&#x27;:[&#x27;t1&#x27;,&#x27;t2&#x27;,&#x27;t3&#x27;,&#x27;t5&#x27;,&#x27;t7&#x27;],                       &#x27;description&#x27;:[&#x27;d1&#x27;,&#x27;d2&#x27;,&#x27;d3&#x27;,&#x27;d5&#x27;,&#x27;d7&#x27;]&#125;)ratings = pd.DataFrame(&#123;&#x27;user_id&#x27;:[1,2,7,9,11],                        &#x27;movie_id&#x27;:[1,2,3,5,6],                        &#x27;title&#x27;:[&#x27;t1&#x27;,&#x27;t2&#x27;,&#x27;t3&#x27;,&#x27;t5&#x27;,&#x27;t6&#x27;],                        &#x27;rating&#x27;:[2,3,1,5,4],                        &#x27;time&#x27;:[&#x27;t1&#x27;,&#x27;t2&#x27;,&#x27;t4&#x27;,&#x27;t4&#x27;,&#x27;t1&#x27;]&#125;)print(pd.merge(movies,ratings)) # 默认是inner joinprint(pd.merge(movies,ratings,on=[&#x27;movie_id&#x27;,&#x27;title&#x27;])) # 指定连接键print(pd.merge(movies,ratings,left_on=&#x27;movie_id&#x27;,right_on=&#x27;user_id&#x27;)) # 指定左右连接键print(pd.merge(movies,ratings,left_index=True,right_index=True)) # 指定左右索引print(pd.merge(movies,ratings,on=[&#x27;movie_id&#x27;],suffixes=[&#x27;_left&#x27;,&#x27;_right&#x27;]))# 指定后缀print(pd.merge(movies,ratings,on=[&#x27;movie_id&#x27;,&#x27;title&#x27;],how=&#x27;outer&#x27;,indicator=&#x27;indicator&#x27;)) # 指定连接方式print(movies.join(ratings,on=&#x27;movie_id&#x27;,lsuffix=&#x27;_left&#x27;,rsuffix=&#x27;_right&#x27;)) # 用join方法连接print(pd.concat([movies,ratings])) # 用concat方法连接print(pd.concat([movies,ratings],ignore_index=True)) # 用concat方法连接print(pd.concat([movies,ratings],join=&#x27;inner&#x27;,axis=1)) # 用concat方法连接print(movies._append([ratings,movies],ignore_index=True)) # 用append方法连接\r\nPandas数据可视化\r\nusa_city_population = pd.DataFrame(&#123;    &#x27;population&#x27;: [8175133,3792621,2695598,2100263,19354922],&#125;,index=[&#x27;New York&#x27;,&#x27;Los Angeles&#x27;,&#x27;Chicago&#x27;,&#x27;Houston&#x27;,&#x27;Phoenix&#x27;]) # 创建数据axs = usa_city_population.plot.pie(y=&#x27;population&#x27;)    # 画饼图china_city_population = pd.DataFrame(&#123;&#x27;population&#x27;: [15773658,2180357, 1208360, 1035837, 10039107]&#125;,index=[&#x27;广州&#x27;,&#x27;上海&#x27;,&#x27;北京&#x27;,&#x27;天津&#x27;,&#x27;重庆&#x27;]) # 创建数据axs = china_city_population.plot.pie(y=&#x27;population&#x27;,figsize = (5,5))    # 画饼图top_city_population = pd.DataFrame(&#123;    &#x27;uas&#x27;:usa_city_population[&#x27;population&#x27;].values,    &#x27;china&#x27;:china_city_population[&#x27;population&#x27;].values&#125;,index=[&#x27;top1&#x27;,&#x27;top2&#x27;,&#x27;top3&#x27;,&#x27;top4&#x27;,&#x27;top5&#x27;]) # 创建数据axs = top_city_population.plot.bar(rot=0)    # 画柱状图top_city_population.reset_index().plot.bar(x=&#x27;index&#x27;,y=[&#x27;china&#x27;],rot=0)    # 画柱状图data=pd.Series(np.random.randn(1000),index=np.arange(1000))axs = data.cumsum().plot()  # 画折线图data=pd.DataFrame(np.random.randn(1000,4),index=np.arange(1000),columns=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;])data=data.cumsum()data.plot.scatter(x=&#x27;A&#x27;,y=&#x27;B&#x27;,color=&#x27;Green&#x27;,label = &#x27;Class1&#x27;)    # 画散点图ax1 = data.plot.scatter(x=&#x27;A&#x27;,y=&#x27;B&#x27;,color=&#x27;Green&#x27;,label = &#x27;Class1&#x27;)  # 画散点图data.plot.scatter(x=&#x27;A&#x27;,y=&#x27;C&#x27;,color=&#x27;Red&#x27;,label = &#x27;Class2&#x27;,ax=ax1)    # 合并散点图data.plot.box()    # 画箱线图data = np.abs(data)axs = data.plot.area(figsize=(12,4),subplots=True)    # 画面积图plt.show()\r\nMatplotlib基础\r\nfigure\r\nx1 = np.linspace(-5,5,50)y1 = 2*x1y2 = x1**2-10plt.figure(figsize=(5,6))plt.plot(x1,y1)plt.show()\r\n\r\n\r\nplot\r\n\r\nplt.plot(x1,y2,color=&quot;green&quot;,linewidth=2,linestyle=&#x27;--&#x27;,label=&#x27;y=x^2-10&#x27;) # 绘制y=x^2-10曲线plt.show()\r\n\r\n\r\nplot\r\n\r\n# 画两条曲线fix,axe = plt.subplots()axe.plot(x1,y1,label=&#x27;y=2x&#x27;)axe.plot(x1,y2,label=&#x27;y=x^2-10&#x27;)plt.show()\r\n\r\n\r\nsubplot\r\n\r\n# 子图fig=plt.figure()plot=fig.add_subplot(121) # 1行2列第1个plot.plot(x1,y1)plot=fig.add_subplot(122) # 1行2列第2个plot.plot(x1,y2)plt.show()#另一种方法plt.subplot(1,2,1)plt.plot(x1,y1)plt.subplot(1,2,2)plt.plot(x1,y2)plt.show()\r\n\r\n\r\nsubplot\r\n\r\n坐标轴和边框\r\nx1 = np.linspace(-5,5,50)y1 = 2*x1y2 = x1**2-10plt.plot(x1,y1)plt.plot(x1,y2)plt.title(&quot;Title&quot;,color=&#x27;red&#x27;,fontsize=20)plt.show()\r\n\r\n\r\n标题\r\n\r\nplt.xlabel(&#x27;x轴&#x27;)plt.ylabel(&#x27;y轴&#x27;)plt.show()\r\n\r\n\r\n坐标轴标题\r\n\r\nplt.xlim((-2,2))plt.ylim((-5,10))plt.show()#另一种方法fig,axe=plt.subplots()axe.plot(x1,y1)axe.plot(x1,y2)axe.set_xlim(-2,2)axe.set_ylim(-5,10)\r\n\r\n\r\n限制坐标轴范围\r\n\r\n#设置刻度线和边框fig,axe=plt.subplots()axe.plot(x1,y1)axe.plot(x1,y2)axe.set_xlim(-2,2)axe.set_ylim(-5,10)axe.set_xticks(np.linspace(-2,2,3)) # 设置x轴刻度axe.tick_params(direction=&#x27;in&#x27;,length=5,width=2,color=&#x27;b&#x27;) # 设置刻度线的方向、长度、宽度和颜色\r\n\r\n\r\n设置刻度线和边框\r\n\r\nfig,axe=plt.subplots()axe.plot(x1,y1)axe.plot(x1,y2)axe.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;,0.5))axe.spines[&#x27;bottom&#x27;].set_position((&#x27;axes&#x27;,0.5)) # 设置坐标轴位置axe.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)axe.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;) # 隐藏坐标轴\r\n\r\n\r\n设置边框\r\n\r\n图例、标注\r\nplt.plot(x1,y1,label=&#x27;y=2x&#x27;)plt.plot(x1,y2,label=&#x27;y=x^2&#x27;)plt.legend(loc=0,title=&quot;legend title&quot;,shadow=True,ncol=2,facecolor=&#x27;gray&#x27;) # loc=0自动选择最佳位置,设置标题，阴影，两列显示，背景为灰色\r\n\r\n\r\n设置图例\r\n\r\n#text无指向性标注plt.plot(x1,y1)plt.plot(x1,y2)plt.text(-1,5,&quot;two functions&quot;,family = &quot;Times New Roman&quot;,fontsize = 12,style = &quot;italic&quot;,color = &quot;r&quot;,weight = &quot;black&quot;,bbox = dict(boxstyle=&quot;round&quot;,facecolor = &quot;none&quot;,ec = &quot;b&quot;)) plt.show()\r\n\r\n\r\n无指向性标注\r\n\r\n#annotate指向性标注plt.plot(x1,y1)plt.plot(x1,y2)plt.annotate(&quot;y=2x&quot;,xy=(1,2),xytext=(2,0),arrowprops=dict(arrowstyle=&quot;-&gt;&quot;,linestyle=&quot;--&quot;,connectionstyle=&quot;arc3,rad=.5&quot;),bbox=dict(boxstyle=&quot;round,pad=0.5&quot;,fc=&quot;none&quot;,ec=&quot;gray&quot;))    #xytext是注释的位置，xy是指向的位置\r\n\r\n\r\n指向性标注\r\n\r\n多图合并、折线图、散点图、柱状图、直方图、面积图、堆叠面积图、箱型图、饼图、热力图、3D图\r\n多图合并\r\nplt.figure(figsize=(8, 5))plt.subplot(2, 3, 2) # 将窗口分为2行3列，当前位置为2plt.plot([0, 10], [0, 10])plt.title(&quot;2,3,2&quot;)plt.subplot(2, 3, 4)plt.plot([0, 10], [0, 10])plt.title(&quot;2,3,4&quot;)plt.subplot(2, 3, 5)plt.plot([0, 10], [0, 10])plt.title(&quot;2,3,5&quot;)plt.tight_layout() # 紧凑图像#另一种方法fig, axe = plt.subplots(nrows = 2, ncols = 2)axe[0][1].plot([0, 10], [0, 10])plt.show()# 修改高度fig, axe = plt.subplots(nrows = 2, ncols = 2, figsize = (10, 4)) # inches (width, height)axe[1][1].plot([0, 10], [0, 10])plt.show()# 修改高度fig, axe = plt.subplots(nrows = 2, ncols = 1)axe[1].plot([0, 10], [0, 10])plt.show()# 绘制多图fig, axe = plt.subplots(nrows=2, ncols=2, figsize=(10, 5))plt.tight_layout()axe[0][0].set_title(&quot;1st subplot&quot;)axe[1][1].set_title(&quot;4th subplot&quot;)axe[1][0].plot([0,10], [0, 10])plt.tight_layout() # 紧凑图像plt.show()# 改变宽度plt.subplot(2, 2, 1)plt.title(&quot;2,2,1&quot;)plt.plot([0, 10], [0, 10])plt.subplot(2, 2, 2)plt.plot([0, 10], [0, 10])plt.title(&quot;2,2,3&quot;)plt.subplot(2, 1, 2)plt.plot([0, 10], [0, 10])plt.title(&quot;2,1,2&quot;)plt.tight_layout() # 紧凑图像plt.show()#使用GridSpecfrom matplotlib.gridspec import GridSpecfig = plt.figure(dpi=100) # the resolution in dots per inchgs = GridSpec(2, 2, width_ratios=[1, 2], height_ratios=[3, 1])ax1 = fig.add_subplot(gs[0]) #gs[0,:]表示占据整列,gs[:,0]表示占据整行ax1.text(0.5, 0.5, &quot;1st plot&quot;,verticalalignment=&#x27;center&#x27;, ha=&#x27;center&#x27;)ax1.plot([0,1], [0, 1])ax2 = fig.add_subplot(gs[1])ax2.text(0.5,0.5,&quot;2nd plot&quot;,verticalalignment=&#x27;center&#x27;, ha=&#x27;center&#x27;)ax3 = fig.add_subplot(gs[2])ax3.text(0.5,0.5,&quot;3rd plot&quot;,verticalalignment=&#x27;center&#x27;, ha=&#x27;center&#x27;)ax4 = fig.add_subplot(gs[3])ax4.text(0.5,0.5,&quot;4th plot&quot;,verticalalignment=&#x27;center&#x27;, ha=&#x27;center&#x27;)plt.show()# 图中图x = np.linspace(-3, 3, 100)y = np.sin(x)fig, ax1 = plt.subplots()ax1.plot(x, y, &#x27;orange&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;Big 1&#x27;)left, bottom, width, height = 0.25, 0.6, 0.2, 0.2ax2 = fig.add_axes([left, bottom, width, height])ax2.plot(x, y2, &#x27;g&#x27;)ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;small 1&#x27;)plt.axes([0.65, 0.2, 0.2, 0.25])plt.plot(x, x ** 2, &#x27;r&#x27;)plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;small 2&#x27;)plt.show()\r\n折线图\r\n#折线图x = np.linspace(-5, 5, 25)fig, axe = plt.subplots(figsize= (8, 5))axe.plot(x, x + 1, linestyle=&#x27;-&#x27;, color=&#x27;r&#x27;, marker=&#x27;x&#x27;, label=&quot;l1&quot;) # solid line style, redaxe.plot(x, x + 2, linestyle=&#x27;--&#x27;, color=&#x27;y&#x27;, marker=&#x27;s&#x27;, label=&quot;l2&quot;) # dashed line style, yellow, squareaxe.plot(x, x + 3, linestyle=&#x27;-.&#x27;, color=&#x27;m&#x27;, marker=&#x27;|&#x27;, label=&quot;l3&quot;) # dash-dot line style, magenta, |axe.plot(x, x + 4, linestyle=&#x27;:&#x27;, color=&#x27;g&#x27;, marker=&#x27;v&#x27;, label=&quot;l4&quot;) # dotted line style, greenaxe.plot(x, x + 5, linestyle=&#x27;-&#x27;, color=&#x27;b&#x27;, marker=&#x27;*&#x27;, label=&quot;l5&quot;) # solid, blue,star axe.plot(x, x + 6, linestyle=&#x27;-&#x27;, color=&#x27;c&#x27;, marker=&#x27;o&#x27;, label=&quot;l6&quot;) # solid, cyan, circle axe.legend()plt.show()x = np.linspace(-4, 4, 100)fig, axe = plt.subplots(figsize= (8, 5))axe.plot(x, np.sin(x), &#x27;--b&#x27; ,x + 1, np.sin(x), &#x27;.r&#x27;) # dashed line blue, point marker redplt.show()\r\n散点图\r\n#散点图# scatter allows us to control the properties of each individual data point, including size, color, edge color, and more.fig, axe = plt.subplots(figsize= (8, 5))rng = np.random.RandomState(66)x = rng.randn(50)y = rng.randn(50)colors = rng.randn(50)sizes = rng.randn(50) * 500axe.grid()axe.scatter(x, y, c=colors, s=sizes, alpha=0.5) # alpha透明度plt.show()\r\n柱状图\r\n# 柱状对比fig, axe = plt.subplots()label = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;]index = np.arange(len(label))values1 = [100, 150, 300, 220, 660, 320]values2 = [200, 160, 200, 300, 800, 400]axe.bar(index, values1, width=0.4)axe.bar(index + 0.4, values2, width=0.4)axe.set_xticks(index+0.15)axe.set_xticklabels(label)plt.show()#柱状总和fig, axe = plt.subplots()label = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;]index = np.arange(len(label))values1 = [100, 150, 300, 220, 660, 320]values2 = [200, 160, 200, 300, 800, 400]axe.bar(index, values1)axe.bar(index, values2, bottom=values1)plt.show()#横向柱状总和barhfig, axe = plt.subplots()label = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;]index = np.arange(len(label))values1 = [100, 150, 300, 220, 660, 320]values2 = [200, 160, 200, 300, 800, 400]axe.barh(index, values1)axe.barh(index, values2, left=values1)axe.set_yticks(index)axe.set_yticklabels(label)plt.show()\r\n直方图\r\n# 显示多个直方图fig, axe = plt.subplots(figsize = (8, 5))np.random.seed(66)data1 = np.random.normal(-1, 1, 5000)data2 = np.random.normal(-2, 1, 5000)data3 = np.random.normal(-1, 2, 5000)axe.hist(data1, bins=50, density=True, alpha=0.35, label=&quot;data1&quot;)axe.hist(data2, bins=50, density=True, alpha=0.35, label=&quot;data2&quot;)axe.hist(data3, bins=50, density=True, alpha=0.35, label=&quot;data3&quot;)axe.legend()plt.show()#做出外边界曲线fig, axe = plt.subplots(figsize = (8, 5))sigma = 1mu = 0np.random.seed(66)data = np.random.normal(mu, sigma, 5000)n, bins, _ = axe.hist(data, bins=50, alpha=0.35, density=True) # n: the values of the histogram bins, bins: the edges of the binsy = ((1 / (np.sqrt(2 * np.pi) * sigma)) *     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))axe.plot(bins, y, &#x27;--r&#x27;)plt.show()\r\n面积图\r\n#面积图，并填充不同颜色fig, axe = plt.subplots(figsize = (8, 5))x = np.arange(0, 5, 0.01)y = np.sin(x * np.pi)axe.fill_between(x, y, where=(y &gt; 0), facecolor = &#x27;b&#x27;, alpha = 0.7)axe.fill_between(x, y, where=(y &lt; 0), facecolor = &#x27;g&#x27;, alpha = 0.7)plt.show()#堆叠面积图stackplotfig, axe = plt.subplots(nrows=2, figsize = (8, 5))x = [1, 2, 3, 4, 5, 6]y = [1, 3, 5, 7, 9, 11]np.random.seed(66)y1 = y + np.random.randint(1, 5, 6) # low = 1, high = 5, size = 6y2 = y + np.random.randint(1, 8, 6)y3 = y + np.random.randint(1, 5, 6)y4 = y + np.random.randint(1, 30, 6)y5 = y + np.random.randint(1, 5, 6)y6 = y + np.random.randint(1, 20, 6)y7 = y + np.random.randint(1, 10, 6)labels = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;]axe[0].stackplot(x, y1, y2, y3, y4, y5, y6, y7, baseline=&quot;sym&quot;) # 基本线将会水平对称与0 (the baseline stack is going to be symmetric around the horizontal 0 line)axe[0].set_xticks(x)axe[0].set_xticklabels(labels)axe[0].set_title(&quot;Symmetric&quot;)axe[1].stackplot(x, y1, y2, y3, y4, y5, y6, y7, baseline=&quot;wiggle&quot;) # 重设基本线，以至于最小化平方斜率的总和 (minimizes the sum of the squared slopes.)axe[1].set_xticks(x) axe[1].set_xticklabels(labels)axe[1].set_title(&quot;Wiggle&quot;)plt.tight_layout()plt.show()\r\n箱型图\r\nfig, axe = plt.subplots(figsize = (8, 5))np.random.seed(66)labels = [&quot;Label1&quot;, &quot;Label2&quot;, &quot;Label3&quot;, &quot;Label4&quot;]values = []values.append(np.random.normal(100, 20, 200)) # mean = 100, std = 20 for 200 valuesvalues.append(np.random.normal(100, 100, 200))values.append(np.random.normal(150, 50, 200))values.append(np.random.normal(150, 70, 200))axe.boxplot(values, labels=labels)axe.boxplot(values, labels=labels, vert=False)axe.boxplot(values, labels=labels,patch_artist=True,            boxprops=dict(facecolor=&#x27;teal&#x27;, color=&#x27;r&#x27;))plt.show()\r\n饼图\r\nfig, axe = plt.subplots(figsize = (8, 5))labels = [&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;, &quot;P5&quot;, &quot;P6&quot;]labels2 = [&quot;S1&quot;, &quot;S2&quot;, &quot;S3&quot;]values = [200, 300, 88, 66, 110, 168]values2 = [500, 100, 200]explode = [0,0,0,0.3,0,0]explode2 = [0, 0.1, 0]# outer circle# pctdistance is used to control the distance between the center of the circle and percentage value.# labeldistance is used to control the distance between the center of the circle and the label.axe.pie(values, radius=1.5, wedgeprops=dict(width=0.5), autopct=&#x27;%.2f%%&#x27;,         pctdistance=0.8, labels=labels, labeldistance=1.05, explode=explode)# inner circleaxe.pie(values2, radius=1, wedgeprops=dict(width=0.5), autopct=&#x27;%.2f%%&#x27;,         pctdistance=0.8, labels=labels2, labeldistance=0.3, explode=explode2)plt.show()\r\n热力图\r\nfig, axe = plt.subplots(figsize = (8, 5))axe.set_xticks(np.arange(len(xlabels)))axe.set_yticks(np.arange(len(ylabels)))axe.set_xticklabels(xlabels)axe.set_yticklabels(ylabels)im = axe.imshow(values)for i in range(len(xlabels)):    for j in range(len(ylabels)):        text = axe.text(i, j, values[i, j],                       horizontalalignment=&quot;center&quot;, verticalalignment=&quot;center&quot;, color=&quot;w&quot;)#显示文本axe.figure.colorbar(im, ax=axe)#颜色条plt.show()\r\n3D图\r\nfig = plt.figure(figsize = (8, 5))axes = plt.axes(projection = &quot;3d&quot;)X = np.linspace(-5, 5, 200)Y = np.linspace(-5, 5, 200)X, Y = np.meshgrid(X, Y)Z = np.cos(np.sqrt(X**2 + Y**2))surf = axes.plot_surface(X, Y, Z, cmap=plt.get_cmap(&quot;plasma&quot;))plt.colorbar(surf)plt.show()\r\n","tags":["数据处理"]},{"title":"Git命令行学习与总结","url":"/2025/04/05/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/","content":"因为网站托管使用已久，所以使用借助GitHub做代码版本控制不需要太多前期准备工作，配置好vscode、GitHub的repository以及和GitHub账号连接的Git即可。\r\n推送步骤\r\n在ssh连接成功后，即可开始配置repository，具体步骤如下。\r\n初始化本地Git仓库\r\n\r\n进入项目目录\r\n在vscode终端中进入项目目录中：\r\ncd &lt;项目目录路径&gt;\r\n初始化Git仓库\r\n如果项目目录还没有被Git管理，运行以下命令初始化：\r\ngit init\r\n添加远程仓库\r\n在Github上创建一个新的仓库：\r\n1.登录到GitHub\r\n2.点击右上角的+，选择New repository\r\n3.填写仓库名称和其他信息，点击Create repository\r\n复制仓库的SSH URL，例如：\r\ngit@github.com:username/repository.git\r\n将远程仓库添加到本地仓库（终端输入）：\r\ngit remote add origin git@github.com:username/repository.git\r\n\r\n添加文件并提交到本地仓库\r\n\r\n添加文件到暂存区\r\n可以选择将所有文件都添加到暂存区，或者将特定文件添加到暂存区：\r\ngit add . //添加所有文件git add &lt;文件名称&gt; //添加特定文件\r\n提交文件到本地仓库\r\n提交文件并添加提交信息\r\ngit commit -m &quot;初始提交&quot;\r\n\r\n推送代码到GitHub远程仓库\r\n\r\n推送到远程仓库\r\n将代码推送到远程仓库的主分支（main或master）\r\ngit push -u origin maingit push origin main --force //强制推送\r\n\r\n验证推送结果\r\n打开GitHub进入仓库页面，检查代码是否已经成功推送。\r\n注意：在将文件添加到暂存区后，GitHub的仓库中是无法查看文件的。提交过程代码有三个存放位置，暂存区-&gt;本地仓库-&gt;远程仓库，只有推送至远程仓库成功后才能看到代码文件。\r\n常用命令\r\n\r\n如果想从暂存区移除文件但保留在工作区中，使用\r\ngit restore --staged &lt;文件名&gt; //移除指定文件git restore --staged . //移除所有文件\r\n或\r\ngit reset &lt;文件名&gt;git reset \r\n如果想从暂存区和工作区中同时删除文件，使用\r\ngit rm &lt;文件名&gt;\r\n查看暂存区状态，使用\r\ngit status\r\n将GitHub代码克隆到本地\r\ngit clone &lt;ssh URL&gt;\r\n\r\n","tags":["代码学习"]},{"title":"New things in the process of Reproducing python games","url":"/2025/04/19/New-things-in-the-process-of-Reproducing-python-games/","content":"TurtleThe turtle module in Python is a standard library module used for creating simple graphics and drawings. It provides a virtual “turtle” that can be controlled to draw shapes, patterns, and animations on the screen. It is often used for educational purposes to teach programming and basic graphics concepts.\nKey features of turtle:\n\nDrawing: You can draw lines,shapes, and patterns by moving the turtle around the screen.\nAnimation: The turtle’s movements can be animated, making it useful for creating simple games or visualizations.\nEvents Handling: It supports keyboard and mouse events,allowing for interactive programs.\nEasy to use: The module is beginner-friendly and requires no prior knowledge of graphics programming.\n\nCommon functions:\n\nforward(distance): Moves the turtle forward by the specified distance.\nbackward(distance): Moves the turtle backward.\nleft(angle): Turns the turtle left by the specified angle.\nright(angle): Turns the turtle right.\npenup()/pendown(): Lifts or lowers the pen to stop or start drawing.\ngoto(x,y): Moves the turtle to a specific position\ncircle(radius): Draws a circle with the given radius.\ncolor(color_name): Sets the turtle’s pen color \nbgcolor(color_name): Sets the background color of the screen.\n\nOther functions:\n\nsetup(): uses to configure the size and position of the turtle graphics window.\nIt has four parameters, which allow for flexibility in defining the window’s dimensions and placement. Four parameters are: width(the first parameter specifies the width of the window in pixels), height(the second parameters specifies the height of the window in pixels.),start x(the third parameter specifies the X-coordinate of the top-left corner of the window on the screen), start y(the fourth parameters specifies the Y-coordinate of the top-left corner of the window on the screen)\n\nhideturtle()\nThe hideturtle() function in your code is used to hide the turtle cursor (the arrow or shape that represents the turtle), where you don’t want the turtle cursor to be visible while drawing or updating the game.\nIt is a simple function that only hides the turtle cursor. It doesn’t require any additional information or parameters because its purpose is singular and straightforward: to make the turtle invisible. It acts on the current turtle object.\n\ntracer()\nThe tracer() is a function used to control the animation speed of the turtle graphics. By default, the turtle module updates the screen after every drawing action, which can make complex drawings slow.\nThe tracer() function allows you to disable or control the frequency of screen updates, making the drawing process faster or smoother.\nSyntax:\ntracer(n=None, delay=None)\nn:If set to 0, it disables automatic screen updates entirely. You will need to call update() manually to refresh the screen. If set to a positive integer, it updates the screen every nth drawing action.\ndelay: Set a delay(in milliseconds) between updates.\n\nlisten()\nlisten() is a function that sets the focus on the Turtle graphics window to capture keyboard events. It enables the program to respond to key presses by associating specific keys with functions using onkey()\n\ndone()\nIn the turtle module, the done() function is used to indicate that the Turtle graphics program has finished executing. It keeps the Turtle graphics window open, allowing the user to view the final state of drawing or game.\nWithout done(), the Turtle graphics window may close immediately after the program finishes running, especially when executed in certain environments.\n\nundo()\nundo() function is used to reverse the last action performed by the turtle. This can include actions like drawing a line, moving the turtle, or writing text.\nwriter.undo()writer.write(state[&#x27;score&#x27;])\nwriter.undo() removes the last action performed by the writer turtle, which is likely the previously written score. This ensures that the old score is erased before writing the update score with writer.write(state[‘state’]).\n\nclear()\nUsed to erase all drawings made by the turtle on the screen. It simply clears the visual content created by the turtle.\n\n\nLambdaIn python, a lambda is a way to create an anonymous function(a function without a name).It is often used for short simple functions that are not reused elsewhere. The syntax for a lambda function is:\nlambda arguments:expression\n\narguments: the input parameters for the function.\nexpression: the single expression that the function evaluates and returns\n\nThe purpose to use Lambda in pacman.py\nUsing lambda allows you to define these small, one-time-use functions inline without needing to define separate named functions for each key press. It keeps the code concise and readable.\nDot(.)In pacman.py, I’ve noticed lots of dots. Let’s discuss the function of these dots and summarize dots’ different functions in Python.\ndef change(x,y):    &quot;&quot;&quot;Change the direction of the pacman&quot;&quot;&quot;    if valid(pacman + vector(x,y)):        aim.x = x        aim.y = y\nThe dot(.) in aim.x is used to access an attribute or method of an object in Python. In this case, aim is an instance of the vector class, and x is one of its attributes. The dot allows you to access or modify the value of x within the aim object.\nGeneral use of the dot(.) in Python:\n\nAccessing Attributes:\n\nExample: aim.x accesses the x attribute of the aim object.\nExample: writer.color access the color method of the writer object\n\n\nCalling Methods:\n\nExample: writer.goto(160,160) calls the goto method of the writer object\n\n\nAccessing Modules or Classes:\n\nExample: random.choice accesses the choice function from the random module.\n\n\n\nAll in all, the dot(.) always serves the same purpose: to access an attribute or method of an object, the specific behavior depends on the object being accassed.\n","categories":["python learning"],"tags":["python"]}]